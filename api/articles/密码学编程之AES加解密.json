{"title":"密码学编程之AES加解密","uid":"ef3be98fdaf42e277f90b9a43c3896d0","slug":"密码学编程之AES加解密","date":"2022-11-18T08:48:45.000Z","updated":"2022-11-18T17:22:37.384Z","comments":true,"path":"api/articles/密码学编程之AES加解密.json","keywords":null,"cover":[],"content":"<h1 id=\"密码学编程之AES加解密\"><a href=\"#密码学编程之AES加解密\" class=\"headerlink\" title=\"密码学编程之AES加解密\"></a>密码学编程之AES加解密</h1><h2 id=\"1-AES加解密原理\"><a href=\"#1-AES加解密原理\" class=\"headerlink\" title=\"1.AES加解密原理\"></a>1.AES加解密原理</h2><p>这一篇博客具体细节比较向详细：<a href=\"https://blog.csdn.net/jiamisoft/article/details/125783821\">https://blog.csdn.net/jiamisoft/article/details/125783821</a></p>\n<p>​    AES是作为DES的替代标准出现的。AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。AES中没有使用Feistel网络，其结构为SP结构。</p>\n<p>128位密钥加密结构示意图：</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202211181651781.png\" alt=\"image-20221118165157755\"></p>\n<h4 id=\"1-字节代换：\"><a href=\"#1-字节代换：\" class=\"headerlink\" title=\"(1)字节代换：\"></a>(1)字节代换：</h4><p>AES的字节代换操作可以简化为查表操作(本质基于一定的数学原理，之后再来填坑)</p>\n<p>初始输入128bit(16字节)数据，可以看成4*4的字节矩阵，把每一个字节通过查表替换成对应字节</p>\n<h4 id=\"2-行位移：\"><a href=\"#2-行位移：\" class=\"headerlink\" title=\"(2)行位移：\"></a>(2)行位移：</h4><p>对于4*4的矩阵，操作为：<br>第0行：保持不动；<br>第1行：循环左移1个字节；<br>第2行：循环左移2个字节；<br>第3行：循环左移3个字节。</p>\n<h4 id=\"3-列混淆：\"><a href=\"#3-列混淆：\" class=\"headerlink\" title=\"(3)列混淆：\"></a>(3)列混淆：</h4><p>实际上为4*4矩阵左边乘上一个固定矩阵</p>\n<p>要注意的是这里矩阵元素的乘法和加法是定义在GF(2^8)上的二元运算，加法相当于异或，乘法比较复杂。(有时间再写)</p>\n<h4 id=\"4-轮密钥加：\"><a href=\"#4-轮密钥加：\" class=\"headerlink\" title=\"(4)轮密钥加：\"></a>(4)轮密钥加：</h4><p>轮密钥与状态矩阵进行逐比特异或操作</p>\n<h4 id=\"5-密钥拓展\"><a href=\"#5-密钥拓展\" class=\"headerlink\" title=\"(5)密钥拓展:\"></a>(5)密钥拓展:</h4><p>密钥是128bit,但要进行11次的轮密钥加，要用初始输入密钥生成后10个密钥</p>\n<p>原理如下图：</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202211190106412.png\" alt=\"9f6a5e3adf19d4cfa99684f44d7615b0.png\"></p>\n<h2 id=\"2-加解密实现代码-AES-128-py\"><a href=\"#2-加解密实现代码-AES-128-py\" class=\"headerlink\" title=\"2.加解密实现代码 AES_128.py\"></a>2.加解密实现代码 AES_128.py</h2><p>基本的输入格式有点怪，懒得改了，希望之后有时间写一版中间字节存储，输入16进制的，但写了一些格式转换函数，通过StrToBinList()函数能将字符串能改成我写的这种输入格式的(不熟悉这样的编程，不知道什么格式处理的最方便就怪起来了)。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#输入为128bit(01二进制串)  [&#39;01100011011010000110111101101110&#39;, &#39;01100111011110010110000101101110&#39;, &#39;01101001011100110111100101111001&#39;, &#39;01100100011100110000000000000000&#39;]\nimport numpy as np\nimport base64 \n\nSubchart &#x3D; [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n\t\t        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n\t\t        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n\t\t        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n\t\t        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n\t\t        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n\t\t        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n\t\t        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n\t\t        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n\t\t        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n\t\t        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n\t\t        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n\t\t        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n\t\t        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n\t\t        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n\t\t        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]\n\ndef StreamListToMix(SL):\n\tmix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor i in range(4):\n\t\ttmp&#x3D;SL[i]\n\t\tfor j in range(4):\n\t\t\tmix[j][i]&#x3D;int(tmp[8*j:8*j+8],2)\n\n\treturn mix\n\n&#39;&#39;&#39;\nStreamListToMix(SL) 的返回值形如\n[[251 133 249  67]\n [ 69 182 143 143]\n [168 239 182  99]\n [159 159 182  99]]\n&#39;&#39;&#39;\n\ndef SubByte(mix):\n\t#字节替换\n\n\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\ttmp&#x3D;bin(mix[i][j])[2:].zfill(8)  #tmp&#x3D;01100011(格式)\n\t\t\tx&#x3D;int(tmp[:4],2)  #行数 6\n\t\t\ty&#x3D;int(tmp[4:],2)  #列数 3\n\t\t\tmix[i][j]&#x3D;Subchart[16*x+y] #查表替换 0xfb,但会自动保存为10进制 251\n\n\treturn mix\n&#39;&#39;&#39;\nSubByte(mix)的返回值形如\n[[251 133 249  67]\n [ 69 182 143 143]\n [168 239 182  99]\n [159 159 182  99]]\n&#39;&#39;&#39;\n\ndef RotHang(mix):\n\t#行位移\n\tres_mix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tres_mix[0]&#x3D;mix[0]\n\tres_mix[1]&#x3D;np.roll(mix[1],-1)\n\tres_mix[2]&#x3D;np.roll(mix[2],-2)\n\tres_mix[3]&#x3D;np.roll(mix[3],-3)\n\n\treturn res_mix\n\n&#39;&#39;&#39;\nRotHang(mix)的返回值形如\n[[251 133 249  67]\n [182 143 143  69]\n [182  99 168 239]\n [ 99 159 159 182]]\n&#39;&#39;&#39;\n\ndef mul(a,b):\n\tif a&#x3D;&#x3D;0x01:\n\t\treturn b         #乘上上1，值不变\n\telif a&#x3D;&#x3D;0x02:\n\t\tif b&amp;128!&#x3D;128:\n\t\t\treturn b&lt;&lt;1\n\t\telse:\n\t\t\ttmp&#x3D;(b&lt;&lt;1)-256\n\t\t\treturn tmp^0x1b    #与上10000000，判断最高位是否为1，不为1直接左移一位\n\telif a&#x3D;&#x3D;0x03:\n\t\treturn mul(0x02,b)^b\n\telif a&#x3D;&#x3D;0x09:\n\t\treturn mul(0x02,mul(0x02,mul(0x02,b)))^b\n\telif a&#x3D;&#x3D;0x0b:\n\t\treturn mul(0x09,b)^mul(0x02,b)\n\telif a&#x3D;&#x3D;0x0d:\n\t\treturn mul(0x02,mul(0x02,mul(0x02,b)))^mul(0x02,mul(0x02,b))^b\n\telif a&#x3D;&#x3D;0x0e:\n\t\treturn mul(0x0d,b)^mul(0x03,b)\n\n\ndef ColMix(mix):\n#列混淆\n\tCM_B&#x3D;[[0x02, 0x03, 0x01, 0x01],\n\t\t[0x01, 0x02, 0x03, 0x01],\n\t\t[0x01, 0x01, 0x02, 0x03],\n\t\t[0x03, 0x01, 0x01, 0x02]]\n\n\tz_array&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor j in range(4):\n\t\tfor q in range(4):\n\t\t\tfor k in range(4):\n\t\t\t\tz_array[j][q]^&#x3D;mul(CM_B[j][k],mix[k][q])\n\n\t#print(z_array)\n\treturn z_array\n\n&#39;&#39;&#39;\nColMix(mix)的返回值形如\n[[ 21 160  99  12]\n [ 13  71 139 128]\n [ 79  76 192 175]\n [222 232  94 239]]\n&#39;&#39;&#39;\n\n\n\ndef RoundKeyAdd(mix_m,mix_k):\n\tres_mix&#x3D;mix_m^mix_k\n\treturn res_mix\n\n\ndef T_SubByte(s):\n\t#字节替换\n\n\ta&#x3D;[] #放置代换后的四个字节对应的16进制\n\t#b&#x3D;[] #放置代换后的四个字节对应的2进制\n\t#print(&#39;s:%s&#39;%s)\n\tfor i in range(4):\n\t\ttmp&#x3D;s[i*8:i*8+8]\n\t\t#print(tmp)\n\t\tx&#x3D;int(tmp[:4],2)  \n\t\t#print(&#39;0b&#39;+tmp[4:])\n\t\ty&#x3D;int(tmp[4:],2)  #2进制转10进制得到行列数 1100001011111011011111100\n\t\t#print(y)\n\t\t#b.append(bin(int(Subchart[x*16+y]))[2:].zfill(8))  #2进制(不加0b)\n\t\ta.append(Subchart[x*16+y])          #16进制(加0x) X  其实储存为10进制了\n\n\t#print(a)\n\n\treturn a\n\ndef RotByte(word):\n\t#字循环： 循环左移一个字节\n\treturn word[8:16]+word[16:24]+word[24:32]+word[0:8]\n\ndef T(w,j): #w为上一组128bit密钥的最后一个字，j为轮次\n\t#T函数\n\tRcon&#x3D;[0x01,0x02,0x04,0x08,0x10,   #轮常量\n\t\t  0x20,0x40,0x80,0x1b,0x36]\n\n\t#第一步：字循环\n\ttmp&#x3D;RotByte(w)\n\t#print(tmp)\n\n\t#第二步字节代换\n\ttmp_2&#x3D;T_SubByte(tmp)\n\t#print(tmp_2)\n\t#第三步轮密钥异或\n\ttmp_3&#x3D;tmp_2[0]^Rcon[j]\n\ttmp_2[0]&#x3D;tmp_3   #tmp_2 形如 [17, 68, 41, 219]\n\n\tResult&#x3D;&#39;&#39;        #将tmp_2转成2进制串\n\n\tfor i in range(4):\n\t\tb_2&#x3D;bin(tmp_2[i])[2:].zfill(8)\n\t\tResult&#x3D;Result+b_2        \n\n\treturn Result\n\ndef WordExp(key):\n#密钥拓展\n\tWords&#x3D;[]\n\tWords.append(key)\n\n\t#print(Words)\n\tfor i in range(10):\n\t\tword&#x3D;[]\n\t\ttmp&#x3D;T(Words[i][3],i)\n\t\t#print(tmp)\n\t\ttmp&#x3D;eval(&#39;0b&#39;+Words[i][0])^eval(&#39;0b&#39;+tmp)\n\t\tword.append(tmp)\n\t\tfor j in range(3):\n\t\t\tword.append(word[j]^eval(&#39;0b&#39;+Words[i][j+1]))\n\t\t#print(word)\n\t\tfor s in range(4):\n\t\t\tword[s]&#x3D;bin(word[s])[2:].zfill(32)\n\t\t\t\n\t\tWords.append(word)\n\t\n\treturn Words\n\ndef encrypt(message,key):\n\tmix&#x3D;message\n\t#mix&#x3D;StreamListToMix(message)\n\tWords&#x3D;WordExp(key)\n\n\t#轮密钥加\n\tw_mix_1&#x3D;StreamListToMix(Words[0])\n\tResult_1&#x3D;RoundKeyAdd(mix,w_mix_1)\n\tfor i in range(9):\n\t\t#字节代换\n\t\t#print(Result_1)\n\t\tResult_2&#x3D;SubByte(Result_1)\n\t\t#行位移\n\t\tResult_2&#x3D;RotHang(Result_2)\n\t\t#print(Result_2)\n\t\t#列混淆\n\t\tResult_2&#x3D;ColMix(Result_2)\n\t\t#print(Result_2)\n\t\t#轮密钥加\n\t\tw_mix_i&#x3D;StreamListToMix(Words[i+1])\n\t\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_i)\n\t\t#print(Result_1)\n\t#第10轮\n\tw_mix_11&#x3D;StreamListToMix(Words[10])\n\t#字节代换\n\tResult_2&#x3D;SubByte(Result_1)\n\t#行位移\n\tResult_2&#x3D;RotHang(Result_2)\n\t#print(Result_2)\n\t#轮密钥加\n\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_11)\n\n\n\treturn Result_1\n\ndef ReSubByte(mix):\n\t#逆字节替换\n\tReSubchart &#x3D; [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7,0xfb,\n\t\t\t\t0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9,0xcb,\n\t\t\t\t0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3,0x4e,\n\t\t\t\t0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1,0x25,\n\t\t\t\t0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6,0x92,\n\t\t\t\t0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d,0x84,\n\t\t\t\t0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45,0x06,\n\t\t\t\t0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a,0x6b,\n\t\t\t\t0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6,0x73,\n\t\t\t\t0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf,0x6e,\n\t\t\t\t0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe,0x1b,\n\t\t\t\t0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a,0xf4,\n\t\t\t\t0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec,0x5f,\n\t\t\t\t0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c,0xef,\n\t\t\t\t0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99,0x61,\n\t\t\t\t0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c,0x7d]\n\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\ttmp&#x3D;bin(mix[i][j])[2:].zfill(8)  #tmp&#x3D;01100011(格式)\n\t\t\tx&#x3D;int(tmp[:4],2)  #行数 6\n\t\t\ty&#x3D;int(tmp[4:],2)  #列数 3\n\t\t\tmix[i][j]&#x3D;ReSubchart[16*x+y] #查表替换 0xfb,但会自动保存为10进制 251\n\n\t\n\treturn mix\n\ndef ReRotHang(mix):\n\t#逆行位移\n\tres_mix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tres_mix[0]&#x3D;mix[0]\n\tres_mix[1]&#x3D;np.roll(mix[1],1)\n\tres_mix[2]&#x3D;np.roll(mix[2],2)\n\tres_mix[3]&#x3D;np.roll(mix[3],3)\n\n\treturn res_mix\n\ndef ReColMix(mix):\n#列混淆\n\tCM_B&#x3D;[[0x0e, 0x0b, 0x0d, 0x09],\n\t\t[0x09, 0x0e, 0x0b, 0x0d],\n\t\t[0x0d, 0x09, 0x0e, 0x0b],\n\t\t[0x0b, 0x0d, 0x09, 0x0e]]\n\n\tz_array&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor j in range(4):\n\t\tfor q in range(4):\n\t\t\tfor k in range(4):\n\t\t\t\tz_array[j][q]^&#x3D;mul(CM_B[j][k],mix[k][q])\n\n\t&#39;&#39;&#39;mix_2&#x3D;&#39;&#39;\n\t\t\t\tfor i in range(4):\n\t\t\t\t\tfor j in range(4):\n\t\t\t\t\t\tmix_2&#x3D;mix_2+str(hex(z_array[j][i]))\n\t\t\t\tprint(mix_2)&#39;&#39;&#39;\n\n\treturn z_array\n\n\ndef decrypt(message,key):\n\t#mix&#x3D;StreamListToMix(message)\n\tmix&#x3D;message\n\tWords&#x3D;WordExp(key)\n\tWords.reverse()\n\t#print(Words)\n\t#轮密钥加\n\tw_mix_1&#x3D;StreamListToMix(Words[0])\n\tResult_1&#x3D;RoundKeyAdd(mix,w_mix_1)\n\tfor i in range(9):\n\t\t#字节代换\n\t\t#print(Result_1)\n\t\tResult_2&#x3D;ReSubByte(Result_1)\n\t\t#行位移\n\t\tResult_2&#x3D;ReRotHang(Result_2)\n\t\t#print(Result_2)\n\t\t\n\t\t#列混淆\n\t\tResult_2&#x3D;ReColMix(Result_2)\n\t\t#print(Result_2)\n\t\t#轮密钥加\n\t\tw_mix_i&#x3D;ReColMix(StreamListToMix(Words[i+1]))\n\t\t#print(w_mix_i)\n\t\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_i)\n\t\t#print(Result_1)\n\t#第10轮\n\tw_mix_11&#x3D;StreamListToMix(Words[10])\n\t#字节代换\n\tResult_2&#x3D;ReSubByte(Result_1)\n\t#行位移\n\tResult_2&#x3D;ReRotHang(Result_2)\n\t#print(Result_2)\n\t#轮密钥加\n\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_11)\n\n\n\treturn Result_1\n\ndef MixToHexStream(mix):  #返回128bit的16进制流\n\tHS&#x3D;&#39;&#39;\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tHS+&#x3D;hex(mix[j][i])[2:]\n\n\treturn HS\n\ndef MixToStr(mix): #返回128bit的字符串\n\tres_str&#x3D;&#39;&#39;\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tres_str+&#x3D;chr(mix[j][i])\n\n\treturn res_str\n\ndef StrToBase64(str1):\n\tb &#x3D; base64.b64encode(str1.encode(&#39;latin&#39;)).decode(&#39;latin&#39;)\n\treturn b\n\ndef Base64ToStr(b):\n\tc &#x3D; base64.b64decode(b.encode(&#39;latin&#39;)).decode(&quot;latin&quot;)\n\treturn c\n\ndef HexStreamToBinList(HS):\n\tP&#x3D;[]\n\tnum_2&#x3D;&#39;&#39;\n\tfor s in HS:\n\t\tb&#x3D;bin(int(s,16))[2:].zfill(4)\n\t\tnum_2+&#x3D;b\n\n\twhile len(num_2) % 128 !&#x3D; 0:\n\t\tnum_2 +&#x3D; &#39;0&#39;                      #不够填充0\n\tprint(num_2)\n\tfor i in range(len(num_2)&#x2F;&#x2F;32):     #按照32bit分组\n\t\tP.append(num_2[i*32:i*32+32])\n\treturn P\n\ndef StrToBinList(string): #将ASCII字符转位二进制分组流\n\tP&#x3D;[]\n\tnum_2&#x3D;&#39;&#39;\n\tfor s in string:\n\t\tnum_10&#x3D;ord(s)\n\t\tnum_2&#x3D;num_2+bin(num_10)[2:].zfill(8) #zfill方法可以指定字符串位数，前面用0填充\n\n\t#print(num_2)\n\twhile len(num_2) % 128 !&#x3D; 0:\n\t\tnum_2 +&#x3D; &#39;0&#39;                      #不够填充0\n\t#print(num_2)\n\tfor i in range(len(num_2)&#x2F;&#x2F;32):     #按照32bit分组\n\t\tP.append(num_2[i*32:i*32+32])\n\n\treturn P\n\ndef main():\n\t#message&#x3D;HexStreamToBinList(&#39;00112233445566778899aabbccddeeff&#39;)\n\t#key&#x3D;HexStreamToBinList(&#39;2b7e151628aed2a6abf7158809cf4f3c&#39;)\n\t#print(message)\n\t#print(key)\n\tmessage&#x3D;[&#39;01100011011010000110111101101110&#39;, &#39;01100111011110010110000101101110&#39;, &#39;01101001011100110111100101111001&#39;, &#39;01100100011100110000000000000000&#39;]\n\tkey&#x3D;[&#39;11101000111010001100110100110100&#39;, &#39;01101000100010011111100000011111&#39;, &#39;10010000000101010100101100110000&#39;, &#39;10011111111000111000011001001100&#39;]\n\tmix&#x3D;StreamListToMix(message)\n\tprint(mix)\n\t#key_mix&#x3D;StreamListToMix(key)\n\t#print(mix)\n\t#sub_mix&#x3D;SubByte(mix)\n\t#print(sub_mix)\n\t#rot_mix&#x3D;RotHang(sub_mix)\n\t#print(rot_mix)\n\t#col_mix&#x3D;ColMix(mix)\n\t#print(col_mix)\n\t#print(WordExp(key))\n\tc&#x3D;encrypt(mix,key)\n\tprint(c)\n\t#print(MixToStr(c))\n\t#print(MixToHexStream(c))\n\t#print(StrToBase64(MixToStr(c)))\n\tp&#x3D;decrypt(c,key)\n\tprint(p)\n\n\t#c&#x3D;mix(c)\n\t#p&#x3D;decrypt(c,key)\n\t#print(MixToStr(p))\n\n\n&#39;&#39;&#39;\nencrypt(message,key)\n[[ 37 116  19 127]\n [223  19  60 168]\n [210  41   2 236]\n [151 238 108 192]]\n&#39;&#39;&#39;\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\tmain()\n</code></pre>\n<p>3.运行结果示意图</p>\n<p>初始矩阵状态-》加密得到的矩阵-》解密后的矩阵</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202211190121067.png\" alt=\"image-20221119012143013\"></p>\n","text":"密码学编程之AES加解密1.AES加解密原理这一篇博客具体细节比较向详细：https://blog.csdn.net/jiamisoft/article/details/125783821 ​ AES是作为DES的替代标准出现的。AES明文分组长度为128位，即16个字节，密钥长...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":4,"path":"api/tags/密码学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BC%96%E7%A8%8B%E4%B9%8BAES%E5%8A%A0%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">密码学编程之AES加解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-AES%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.AES加解密原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AD%97%E8%8A%82%E4%BB%A3%E6%8D%A2%EF%BC%9A\"><span class=\"toc-text\">(1)字节代换：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%A1%8C%E4%BD%8D%E7%A7%BB%EF%BC%9A\"><span class=\"toc-text\">(2)行位移：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%88%97%E6%B7%B7%E6%B7%86%EF%BC%9A\"><span class=\"toc-text\">(3)列混淆：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BD%AE%E5%AF%86%E9%92%A5%E5%8A%A0%EF%BC%9A\"><span class=\"toc-text\">(4)轮密钥加：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%AF%86%E9%92%A5%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">(5)密钥拓展:</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-AES-128-py\"><span class=\"toc-text\">2.加解密实现代码 AES_128.py</span></a></li></ol></li></ol>","author":{"name":"c1ongyan","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"实施ARP攻击与欺骗","uid":"350110abdd9efa15378005351b5f698f","slug":"实施ARP攻击与欺骗","date":"2022-11-05T12:40:42.000Z","updated":"2022-11-18T08:46:53.969Z","comments":true,"path":"api/articles/实施ARP攻击与欺骗.json","keywords":null,"cover":[],"text":"实施ARP攻击与欺骗1.ARP欺骗原理ARP欺骗通过伪造ARP应答包实施欺骗 2.实施ARP欺骗环境：攻击机：Kali 靶机：win7 x64 (1)开启路由转发echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_...","link":"","photos":[],"count_time":{"symbolsCount":475,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"web","slug":"web","count":2,"path":"api/tags/web.json"}],"author":{"name":"c1ongyan","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}