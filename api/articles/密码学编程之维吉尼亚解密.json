{"title":"密码学编程之维吉尼亚解密","uid":"7578f0af2d88f971b7e36554470841ec","slug":"密码学编程之维吉尼亚解密","date":"2022-10-02T07:03:43.000Z","updated":"2022-10-02T17:52:20.548Z","comments":true,"path":"api/articles/密码学编程之维吉尼亚解密.json","keywords":null,"cover":[],"content":"<h1 id=\"密码学编程之维吉尼亚解密\"><a href=\"#密码学编程之维吉尼亚解密\" class=\"headerlink\" title=\"密码学编程之维吉尼亚解密\"></a>密码学编程之维吉尼亚解密</h1><h2 id=\"1-什么是维吉尼亚密码\"><a href=\"#1-什么是维吉尼亚密码\" class=\"headerlink\" title=\"1.什么是维吉尼亚密码\"></a>1.什么是维吉尼亚密码</h2><p>它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式的密钥，即每隔一个周期用同一张表（即同一偏移）来加密。</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210021509869.png\" alt=\"img\"></p>\n<p>示例：</p>\n<p>密钥为：encryption</p>\n<p>明文为：publickeydistribution</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210021519981.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-维吉尼亚解密\"><a href=\"#2-维吉尼亚解密\" class=\"headerlink\" title=\"2.维吉尼亚解密\"></a>2.维吉尼亚解密</h2><h3 id=\"2-1已知密钥的维吉尼亚解密\"><a href=\"#2-1已知密钥的维吉尼亚解密\" class=\"headerlink\" title=\"2.1已知密钥的维吉尼亚解密\"></a>2.1已知密钥的维吉尼亚解密</h3><p>思路：做加密的逆过程即可。加密是按照密钥进行凯撒加密，解密就是按照密钥进行凯撒解密。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import wordninja #wordninja是分词工具\n\nLetters&#x3D;&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\n\ndef decrypt(key,message):\n\n\tresult&#x3D;&#39;&#39;\n\tl&#x3D;len(key)\n\tj&#x3D;0\n\n\tfor i in message:\n\t\tindex&#x3D;(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj&#x3D;(j+1)%l\n\t\tresult&#x3D;result+Letters[index]\n\n\ttext&#x3D;&#39; &#39;.join(wordninja.split(result)) #对解密结果按英文分词，增加可读性\n\n\treturn text\n\n\ndef main():\n\tmessage&#x3D;&#39;krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy&#39;\n\tkey&#x3D;&#39;CRYPTO&#39;\n\tprint(decrypt(key,message.upper()))\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\tmain()</code></pre>\n<h3 id=\"2-2唯密文的维吉尼亚解密\"><a href=\"#2-2唯密文的维吉尼亚解密\" class=\"headerlink\" title=\"2.2唯密文的维吉尼亚解密\"></a>2.2唯密文的维吉尼亚解密</h3><h4 id=\"2-2-1利用重合指数-重合互指数解密\"><a href=\"#2-2-1利用重合指数-重合互指数解密\" class=\"headerlink\" title=\"2.2.1利用重合指数+重合互指数解密\"></a>2.2.1利用重合指数+重合互指数解密</h4><p>此种方法对于唯密文的维吉尼亚解密是基于语言的统计规律，所以当密文很短是是无法用该方法解密的，对长密文比较适用</p>\n<p>思路：</p>\n<p>1.根据kasiski或者重合指数计算出密钥长度</p>\n<p>Kasiski测验法基本原理：用给定长度为k的密钥周期性地对明文加密，则但明文中有两个相同的字母，且对应被加密后的字母也相同时，这两个字母的间距是k的倍数。找到密文中相同字母间隔的最大公因数，很有可能是密钥长度。</p>\n<p>重合指数法：对单表替换而已，并不会改变字符串的统计特性（比如，某个英语字母出现的频率），故其重合指数应该约等于0.065。可以爆破密钥长度，根据密钥长度将同一密钥字母加密的字母放在一个分组内，每个分组都相当于被单表替换，都应满足重合指数应该约等于0.065。</p>\n<p>重合指数:两个随机字母相同的概率（即在一字符串中随机取出两个字母为a的概率+同为b的概率+…）</p>\n<script type=\"math/tex; mode=display\">\nIC=\\sum_{i=1}^{n} p_i^2</script><p>（pi为字母i出现频率）</p>\n<p>重合指数无偏估计值(更准确，用此来计算):</p>\n<script type=\"math/tex; mode=display\">\nIC^{'}=\\sum_{i=1}^{n}\\frac{f_i(f_i-1)}{n(n-1)}</script><p>（fi为字母i出现次数，n为字符串字符总数）</p>\n<p>代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def getCnt(string):\n#统计字符出现的次数\n\tLettersZd&#x3D;&#123;&#39;A&#39;:0, &#39;B&#39;:0, &#39;C&#39;: 0, &#39;D&#39;: 0, &#39;E&#39;: 0, &#39;F&#39;: 0, &#39;G&#39;: 0, &#39;H&#39;: 0, &#39;I&#39;: 0, &#39;J&#39;: 0, &#39;K&#39;: 0, &#39;L&#39;: 0, &#39;M&#39;: 0, &#39;N&#39;: 0, &#39;O&#39;: 0, &#39;P&#39;: 0, &#39;Q&#39;: 0, &#39;R&#39;: 0, &#39;S&#39;: 0, &#39;T&#39;: 0, &#39;U&#39;: 0, &#39;V&#39;: 0, &#39;W&#39;: 0, &#39;X&#39;: 0, &#39;Y&#39;: 0, &#39;Z&#39;: 0&#125;\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+&#x3D;1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi&#x3D;0\n\tn&#x3D;0 #总数n\n\tfor k in Zd:\n\t\tfi&#x3D;fi+Zd[k]*(Zd[k]-1)\n\t\tn&#x3D;n+Zd[k]\n\n\tp&#x3D;fi&#x2F;(n*(n-1))\n\n\treturn p\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt&#x3D;0\n\tpi&#x3D;0\n\tfor i in range(1,len(Letters)):\n\t\t#print(&#39;key_length&#x3D;%s&#39;%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr&#x3D;message[j::i]\n\t\t\tLettersZd&#x3D;getCnt(str)\n\n\t\t\tpi&#x3D;getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+&#x3D;1\n\t\tif cnt&#x3D;&#x3D;i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt&#x3D;0\n\t\tpi&#x3D;0</code></pre>\n<h4 id=\"2-根据重合互指数得到密钥\"><a href=\"#2-根据重合互指数得到密钥\" class=\"headerlink\" title=\"2.根据重合互指数得到密钥\"></a>2.根据重合互指数得到密钥</h4><p>重合互指数：</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210021638455.png\" alt=\"image-20221002163842394\"></p>\n<p>当两个子串的相对位移为0时其值为0.065，不为0则都在0.3~0.4左右，故我们可以把其中一子串设为标准英语，另一子串为根据密钥长度分组后的子串，爆破26种偏移，重合互指数最大的应该是子串相对标准英语的偏移，从而确定对应密钥字母。</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210021640346.png\" alt=\"image-20221002164000301\"></p>\n<p>代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1&#x3D;[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2&#x3D;getCnt(str_1)\n\n\tmatrix_1&#x3D;np.array(Zd_1)\n\tmatrix_2&#x3D;np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2&#x3D;np.sum(matrix_2)\n\tpi&#x3D;matrix_2&#x2F;n2\n\n\tHp&#x3D;np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult&#x3D;&#39;&#39;\n\tfor s in string:\n\t\tindex&#x3D;Letters.find(s)\n\t\tresult&#x3D;result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm&#x3D;0\n\tresult&#x3D;[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring&#x3D;KaiSa(i,group[num])\n\t\tx&#x3D;getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm&#x3D;x\n\t\t\tkey&#x3D;i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len&#x3D;getLenKey(message)\n\n\n\tgroup&#x3D;[] #按照密钥长度分组\n\th_key&#x3D;&#123;&#125; #存储偏移K\n\tMI&#x3D;&#123;&#125; #储存偏移值\n\tLetter_key&#x3D;&#39;&#39;#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]&#x3D;getListMI(i,group)\n\n\t\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm&#x3D;Letters[26-h_key[i]]\n\t\tLetter_key&#x3D;Letter_key+m\n\n\treturn Letter_key</code></pre>\n<h4 id=\"3-已知密钥的维吉尼亚解密\"><a href=\"#3-已知密钥的维吉尼亚解密\" class=\"headerlink\" title=\"3.已知密钥的维吉尼亚解密\"></a>3.已知密钥的维吉尼亚解密</h4><p>代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def decrypt(key,message):\n\n\tresult&#x3D;&#39;&#39;\n\tl&#x3D;len(key)\n\tj&#x3D;0\n\n\tfor i in message:\n\t\tindex&#x3D;(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj&#x3D;(j+1)%l\n\t\tresult&#x3D;result+Letters[index]\n\n\ttext&#x3D;&#39; &#39;.join(wordninja.split(result))  #利用wordninja分词工具自动分词，增加明文可读性\n\n\treturn text</code></pre>\n<h4 id=\"4-完整代码及运行结果示例\"><a href=\"#4-完整代码及运行结果示例\" class=\"headerlink\" title=\"4.完整代码及运行结果示例\"></a>4.完整代码及运行结果示例</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#维吉尼亚解密：不知道密钥情况下分析密钥，求出密文(适合长密文)\n#思路：1.求出密钥长度：方法可以用kasiski或者重合指数,这里用重合指数法\n#重合指数法思路：爆破key长度，将一组的子串计算重合指数p^2和(近似)，每一个子串重合指数都在0.065左右的则为真实密钥长度\n#2.破解密钥：根据重合互指数，爆破相对偏移\n#3.求解密文:已知密钥求密文\n\n&#39;&#39;&#39;\n表达难点：\n子串计算的处理&#x3D;&#x3D;&gt;直接利用字符串自带的按步长分片\n重合指数的存储判断&#x3D;&#x3D;&gt;方法一:计算平均值判断\n重合互指数需要将已满足条件的\n如何判断是约等于0.065\n&#39;&#39;&#39;\nimport numpy as np\nimport wordninja\n\nLetters&#x3D;&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\n\ndef getCnt(string):\n#统计字符出现的频率\n\tLettersZd&#x3D;&#123;&#39;A&#39;:0, &#39;B&#39;:0, &#39;C&#39;: 0, &#39;D&#39;: 0, &#39;E&#39;: 0, &#39;F&#39;: 0, &#39;G&#39;: 0, &#39;H&#39;: 0, &#39;I&#39;: 0, &#39;J&#39;: 0, &#39;K&#39;: 0, &#39;L&#39;: 0, &#39;M&#39;: 0, &#39;N&#39;: 0, &#39;O&#39;: 0, &#39;P&#39;: 0, &#39;Q&#39;: 0, &#39;R&#39;: 0, &#39;S&#39;: 0, &#39;T&#39;: 0, &#39;U&#39;: 0, &#39;V&#39;: 0, &#39;W&#39;: 0, &#39;X&#39;: 0, &#39;Y&#39;: 0, &#39;Z&#39;: 0&#125;\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+&#x3D;1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi&#x3D;0\n\tn&#x3D;0 #总数n\n\tfor k in Zd:\n\t\tfi&#x3D;fi+Zd[k]*(Zd[k]-1)\n\t\tn&#x3D;n+Zd[k]\n\n\tp&#x3D;fi&#x2F;(n*(n-1))\n\n\treturn p\n\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt&#x3D;0\n\tpi&#x3D;0\n\tfor i in range(1,len(Letters)):\n\t\t#print(&#39;key_length&#x3D;%s&#39;%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr&#x3D;message[j::i]\n\t\t\tLettersZd&#x3D;getCnt(str)\n\n\t\t\tpi&#x3D;getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+&#x3D;1\n\t\tif cnt&#x3D;&#x3D;i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt&#x3D;0\n\t\tpi&#x3D;0\n\n\ndef getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1&#x3D;[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2&#x3D;getCnt(str_1)\n\n\tmatrix_1&#x3D;np.array(Zd_1)\n\tmatrix_2&#x3D;np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2&#x3D;np.sum(matrix_2)\n\tpi&#x3D;matrix_2&#x2F;n2\n\n\tHp&#x3D;np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult&#x3D;&#39;&#39;\n\tfor s in string:\n\t\tindex&#x3D;Letters.find(s)\n\t\tresult&#x3D;result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm&#x3D;0\n\tresult&#x3D;[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring&#x3D;KaiSa(i,group[num])\n\t\tx&#x3D;getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm&#x3D;x\n\t\t\tkey&#x3D;i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len&#x3D;getLenKey(message)\n\n\n\tgroup&#x3D;[] #按照密钥长度分组\n\th_key&#x3D;&#123;&#125; #存储偏移K\n\tMI&#x3D;&#123;&#125; #储存偏移值\n\tLetter_key&#x3D;&#39;&#39;#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]&#x3D;getListMI(i,group)\n\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm&#x3D;Letters[(26-h_key[i])%26]\n\t\tLetter_key&#x3D;Letter_key+m\n\n\treturn Letter_key\n\t\n\ndef decrypt(key,message):\n\n\tresult&#x3D;&#39;&#39;\n\tl&#x3D;len(key)\n\tj&#x3D;0\n\n\tfor i in message:\n\t\tindex&#x3D;(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj&#x3D;(j+1)%l\n\t\tresult&#x3D;result+Letters[index]\n\n\ttext&#x3D;&#39; &#39;.join(wordninja.split(result))\n\n\treturn text\n\ndef main():\n\tmessage&#x3D;&#39;krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy&#39;\n\tmessage&#x3D;message.replace(&quot; &quot;, &quot;&quot;) #清除输入中的空格\n\t#print(message)\n\t#print(getLenKey(message))\n\ts&#x3D;getKey(message.upper())\n\tprint(&#39;密钥为：%s&#39;%s)\n\tt&#x3D;decrypt(s,message.upper())\n\tprint(&#39;解密结果为：%s&#39;%t)\n\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\tmain()\n\n</code></pre>\n<p>运行结果：</p>\n<p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210021656478.png\" alt=\"image-20221002165614406\"></p>\n<h3 id=\"2-2-2字典攻击\"><a href=\"#2-2-2字典攻击\" class=\"headerlink\" title=\"2.2.2字典攻击\"></a>2.2.2字典攻击</h3><p>暂空，写完Hill再来补</p>\n","feature":true,"text":"密码学编程之维吉尼亚解密1.什么是维吉尼亚密码它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">密码学编程之维吉尼亚解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">1.什么是维吉尼亚密码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">2.维吉尼亚解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1%E5%B7%B2%E7%9F%A5%E5%AF%86%E9%92%A5%E7%9A%84%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">2.1已知密钥的维吉尼亚解密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E5%94%AF%E5%AF%86%E6%96%87%E7%9A%84%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">2.2唯密文的维吉尼亚解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1%E5%88%A9%E7%94%A8%E9%87%8D%E5%90%88%E6%8C%87%E6%95%B0-%E9%87%8D%E5%90%88%E4%BA%92%E6%8C%87%E6%95%B0%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">2.2.1利用重合指数+重合互指数解密</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A0%B9%E6%8D%AE%E9%87%8D%E5%90%88%E4%BA%92%E6%8C%87%E6%95%B0%E5%BE%97%E5%88%B0%E5%AF%86%E9%92%A5\"><span class=\"toc-text\">2.根据重合互指数得到密钥</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%B7%B2%E7%9F%A5%E5%AF%86%E9%92%A5%E7%9A%84%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">3.已知密钥的维吉尼亚解密</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%8F%8A%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">4.完整代码及运行结果示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2%E5%AD%97%E5%85%B8%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">2.2.2字典攻击</span></a></li></ol></li></ol></li></ol>","author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"密码学编程之仿射解密","uid":"d57c63b0ac830d2c732299e1855fc44f","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","updated":"2022-10-02T07:04:18.430Z","comments":true,"path":"api/articles/密码学编程之仿射解密.json","keywords":null,"cover":[],"text":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度 以26位大写字母为密文空间的加密表达式如下： m=a*c+b(mod26)m=a*c+b(mod 26) 2.破译仿射加密(以26位大写字母为密文空间为例)在已知密钥a和b的情况下可以...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}