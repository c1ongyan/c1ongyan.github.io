{"title":"密码学编程之仿射解密","uid":"d57c63b0ac830d2c732299e1855fc44f","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","updated":"2022-10-03T04:25:22.225Z","comments":true,"path":"api/articles/密码学编程之仿射解密.json","keywords":null,"cover":[],"content":"<h1 id=\"密码学编程之仿射解密\"><a href=\"#密码学编程之仿射解密\" class=\"headerlink\" title=\"密码学编程之仿射解密\"></a>密码学编程之仿射解密</h1><h2 id=\"1-仿射加密\"><a href=\"#1-仿射加密\" class=\"headerlink\" title=\"1.仿射加密\"></a>1.仿射加密</h2><p>简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度</p>\n<p>以26位大写字母为密文空间的加密表达式如下：</p>\n<script type=\"math/tex; mode=display\">\nm=a*c+b(mod26)</script><p>m=a*c+b(mod 26)</p>\n<h2 id=\"2-破译仿射加密-以26位大写字母为密文空间为例\"><a href=\"#2-破译仿射加密-以26位大写字母为密文空间为例\" class=\"headerlink\" title=\"2.破译仿射加密(以26位大写字母为密文空间为例)\"></a>2.破译仿射加密(以26位大写字母为密文空间为例)</h2><p>在已知密钥a和b的情况下可以很容易求出密文</p>\n<p>以26位大写字母为密文空间的解密表达式如下：</p>\n<script type=\"math/tex; mode=display\">\nc=(m-b)*a^{-1}(mod 26)</script><p>在不知道密钥a和密钥b的情况下由于密钥空间小也很好爆破，因为为了保证能还原明文，必须要能够求出a的逆，这就要求a和26要互素，这样a只有12种可能，b有26种可能，总共12*26-1种可能，非常少，爆破很快。</p>\n<p>但要找出正确的一种可能用肉眼看太麻烦了，可以写一个判断是否是英文的脚本筛选一下，给出一个Al写的脚本detectEnglish.py：(注意需要有一个英文字典txt文件 dictionary.txt)</p>\n<h3 id=\"detectEnglish-py\"><a href=\"#detectEnglish-py\" class=\"headerlink\" title=\"detectEnglish.py\"></a>detectEnglish.py</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># Detect English module\n# http://inventwithpython.com/hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http://invpy.com/dictionary.txt)\nUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \\t\\n'\n\ndef loadDictionary():\n    dictionaryFile = open('dictionary.txt')\n    englishWords = {}\n    for word in dictionaryFile.read().split('\\n'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) / len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return ''.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) / len(message) * 100\n    lettersMatch = messageLettersPercentage &gt;= letterPercentage\n    return wordsMatch and lettersMatch</code></pre>\n<p>这个脚本能帮我们淘汰掉很多种情况，但还是不能唯一得出密文，为了更好锁定密文，对于长文本来说可以引入词频分析，确定明文中E的正确位置(仿射加密本质是更简单的单表替换，出现频率最多的字符大概率就是E),帮助更好的判断出正确的明文</p>\n<p>最后的脚本如下(对长密文适用)：</p>\n<h3 id=\"AffineHack-py\"><a href=\"#AffineHack-py\" class=\"headerlink\" title=\"AffineHack.py\"></a>AffineHack.py</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#Affine Cipher Hacker\nimport math,sys,detectEnglish,wordninja\nfrom gmpy2 import invert\n\nenglishLetterFrea={'E':12.7,'T':9.06,'A':8.17,'O':7.51,'I':6.97,'N':6.75,'S':6.33,'H':6.09,'R':5.99,'D':4.25,'L':4.03,'C':2.78,'U':2.76,'M':2.41,'W':2.36,'F':2.23,'G':2.02,'Y':1.97,'P':1.93,'B':1.29,'V':0.98,'K':0.77,'J':0.15,'X':0.15,'Q':0.10,'Z':0.07}\n\n\nETAOIN='ETAOINSHRDLCUMWFGYPBVKJXQZ'  #英文中词频排列顺序（降序）\n\nSymbols='ABCDEFGHIJKLMNOPQRSTUVWXYZ'  #明文空间 密文空间\n\ndef getLetterCount(message):\n\n#统计字符串中每个字母的数量\n\tLetterCount={'A':0,'B':0,'C':0,'D':0,'E':0,'F':0,'G':0,'H':0,'I':0,'J':0,'K':0,'L':0,'M':0,'N':0,'O':0,'P':0,'Q':0,'R':0,'S':0,'T':0,'U':0,'V':0,'W':0,'X':0,'Y':0,'Z':0}\n\n\tfor i in message.upper():\n\t\tif i in Symbols:\n\t\t\tLetterCount[i]+=1\n\t\n\treturn LetterCount\n\n\n\ndef getItemAtIndexZero(x):\n#返回变量的下标为0的值\n\treturn x[0]\n\ndef getFrequencyOrder(message):\n#按照字母出现的次数排序\n\tletterToFreq=getLetterCount(message) #字母到次数的映射\n\tfreqToLetter={} #次数到字母的映射\n\n\tfor i in Symbols:          \n\t\tif letterToFreq[i] not in freqToLetter:   #判断字母对应次数是否是字典freqToLetter的键，若不是则以该次数为键，以对于的字母为值；若是，则在最后追加一组键值对\n\t\t\tfreqToLetter[letterToFreq[i]]=[i]     #因为次数可能出现相同的情况\n\t\telse:\n\t\t\tfreqToLetter[letterToFreq[i]].append(i)\n\n\tfor freq in freqToLetter:\n\t\tfreqToLetter[freq].sort(key=ETAOIN.find,reverse=True)  #将同一次数的键所对应的字母按照ETAOIN的降序排列(做一个约定)\n\t\tfreqToLetter[freq]=''.join(freqToLetter[freq])\n\n\tfreqPairs=list(freqToLetter.items())                 #将字典变成一个元组列表\n\tfreqPairs.sort(key=getItemAtIndexZero,reverse=True)  #按照元组列表索引为0的值排序\n\n\treturn freqPairs\n\n\n\n\ndef getKey(key):\n\t#得到两个ab密钥\n\tkey_a=key//len(Symbols)\n\tkey_b=key%len(Symbols)\n\treturn (key_a,key_b)\n\ndef checkKeys(key_a,key_b,mode):\n\t#检查密钥是否合法\n\tif mode=='encrypt':\n\t\tif key_a==1 or key_b==1:\n\t\t\tsys.exit('太简单')\n\tif key_a&lt;0 or key_b&lt;0 or key_b&gt;len(Symbols)-1:\n\t\tsys.exit('不属于区间(0,len(Symbols))')\n\tif math.gcd(key_a,len(Symbols))!=1:\n\t\tsys.exit('密钥a和模数不互素')\n\ndef decryptM(key,message):\n\t#已知密钥的仿射解密\n\tK1,K2=getKey(key)\n\tcheckKeys(K1,K2,'decrypt')\n\tresult=''\n\tmodInverseOfKeya=invert(K1,len(Symbols))    #求密钥a的模逆元\n\n\tfor i in message:\n\t\tif i in Symbols:\n\t\t\tIndex=Symbols.find(i)\n\t\t\tresult+=Symbols[((Index-K2)*modInverseOfKeya)%len(Symbols)]\n\t\telse:\n\t\t\tresult+=i\n\n\treturn result\n\ndef hackAffine(message):  \n#爆破得到明文\n\tcnt=0 #最后输出的可能解密结果数\n\n\tMax=getFrequencyOrder(message)[0][1]\n\n\tfor i in message:\n\t\tif i==Max:\n\t\t\tind = message.find(i)   #找到E所在的位置\n\t\t\tbreak\n#                  \n\tprint('hacking start')\n\n\tfor key in range(len(Symbols)**2):   #爆破密钥\n\t\tkey_a=getKey(key)[0]\n\t\tif math.gcd(key_a,len(Symbols))!=1:  #密钥a要和模数互素\n\t\t\tcontinue\n\n\t\tresult=decryptM(key,message)  #将密钥带入根据公式求出对应明文\n\n\t\tif result[ind]=='E':\n\t\t\t#print('tried key %s...(%s)'%(key,result[:20]))\n\t\t\ttext=' '.join(wordninja.split(result))  #利用wordninja工具给字符串分词，这样才能用detectEnglish判断是否是英文\n\t\t\tif detectEnglish.isEnglish(text):    #利用detectEnglish判断是否是英文\n\t\t\t\tcnt+=1\n\t\t\t\tprint('possible encryption hack:')\n\t\t\t\tprint('key:%s'%(key))\n\t\t\t\tprint('c:'+result[:50])\n\t\t\t\tprint(text)                      #输出最后可能结果\n\treturn cnt\n\ndef main():\n\tMessage='FMXVEDKAPHFERBNDKRXRSREFMORUDSDKDVSHVUFEDKAPRKDLYEVLRHHRH'  # 输入密文\n\n\tHackedM=hackAffine(Message)\n\n\tif HackedM!=0:           #如果最后测得的可能解不为0，则成功解密\n\t\tprint('Success')\n\telse:\n\t\tprint('Failed')\n\nif __name__=='__main__':\n\tmain()\n</code></pre>\n<h2 id=\"3-运行示例\"><a href=\"#3-运行示例\" class=\"headerlink\" title=\"3.运行示例\"></a>3.运行示例</h2><p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202209241141751.png\" alt=\"image-20220924114055620\"></p>\n","feature":true,"text":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度 以26位大写字母为密文空间的加密表达式如下： m=a*c+b(mod26)m=a*c+b(mod 26) 2.破译仿射加密(以26位大写字母为密文空间为例)在已知密钥a和b的情况下可以...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BB%BF%E5%B0%84%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">密码学编程之仿射解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">1.仿射加密</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%A0%B4%E8%AF%91%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86-%E4%BB%A526%E4%BD%8D%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E4%B8%BA%E5%AF%86%E6%96%87%E7%A9%BA%E9%97%B4%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">2.破译仿射加密(以26位大写字母为密文空间为例)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#detectEnglish-py\"><span class=\"toc-text\">detectEnglish.py</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AffineHack-py\"><span class=\"toc-text\">AffineHack.py</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">3.运行示例</span></a></li></ol></li></ol>","author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"密码学编程之维吉尼亚解密","uid":"7578f0af2d88f971b7e36554470841ec","slug":"密码学编程之维吉尼亚解密","date":"2022-10-02T07:03:43.000Z","updated":"2022-10-03T04:25:07.960Z","comments":true,"path":"api/articles/密码学编程之维吉尼亚解密.json","keywords":null,"cover":[],"text":"密码学编程之维吉尼亚解密1.什么是维吉尼亚密码它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"typora+picgo+github图床搭建","uid":"ce37acc016e9206d79635834f119399c","slug":"typora-picgo-github图床搭建","date":"2022-07-28T15:04:49.000Z","updated":"2022-07-28T16:41:22.052Z","comments":true,"path":"api/articles/typora-picgo-github图床搭建.json","keywords":null,"cover":[],"text":"typora+picgo+github 图床搭建及常见问题解决方式1.创建GitHub账号GitHub网址： https://github.com/ 2.创建仓库 3.获取token进入设置 进入developer setting 注意repo一定要选择 获取token，记得复制...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"PicGo","slug":"PicGo","count":1,"path":"api/tags/PicGo.json"}],"author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}