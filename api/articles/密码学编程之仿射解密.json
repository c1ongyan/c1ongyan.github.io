{"title":"密码学编程之仿射解密","uid":"d57c63b0ac830d2c732299e1855fc44f","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","updated":"2022-10-02T07:04:18.430Z","comments":true,"path":"api/articles/密码学编程之仿射解密.json","keywords":null,"cover":[],"content":"<h1 id=\"密码学编程之仿射解密\"><a href=\"#密码学编程之仿射解密\" class=\"headerlink\" title=\"密码学编程之仿射解密\"></a>密码学编程之仿射解密</h1><h2 id=\"1-仿射加密\"><a href=\"#1-仿射加密\" class=\"headerlink\" title=\"1.仿射加密\"></a>1.仿射加密</h2><p>简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度</p>\n<p>以26位大写字母为密文空间的加密表达式如下：<br>$$<br>m&#x3D;a<em>c+b(mod26)<br>$$<br>m&#x3D;a</em>c+b(mod 26)</p>\n<h2 id=\"2-破译仿射加密-以26位大写字母为密文空间为例\"><a href=\"#2-破译仿射加密-以26位大写字母为密文空间为例\" class=\"headerlink\" title=\"2.破译仿射加密(以26位大写字母为密文空间为例)\"></a>2.破译仿射加密(以26位大写字母为密文空间为例)</h2><p>在已知密钥a和b的情况下可以很容易求出密文</p>\n<p>以26位大写字母为密文空间的解密表达式如下：<br>$$<br>c&#x3D;(m-b)<em>a^{-1}(mod 26)<br>$$<br>在不知道密钥a和密钥b的情况下由于密钥空间小也很好爆破，因为为了保证能还原明文，必须要能够求出a的逆，这就要求a和26要互素，这样a只有12种可能，b有26种可能，总共12</em>26-1种可能，非常少，爆破很快。</p>\n<p>但要找出正确的一种可能用肉眼看太麻烦了，可以写一个判断是否是英文的脚本筛选一下，给出一个Al写的脚本detectEnglish.py：(注意需要有一个英文字典txt文件 dictionary.txt)</p>\n<h3 id=\"detectEnglish-py\"><a href=\"#detectEnglish-py\" class=\"headerlink\" title=\"detectEnglish.py\"></a>detectEnglish.py</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># Detect English module\n# http:&#x2F;&#x2F;inventwithpython.com&#x2F;hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a &quot;dictionary.txt&quot; file in this directory with all English\n# words in it, one word per line. You can download this from\n# http:&#x2F;&#x2F;invpy.com&#x2F;dictionary.txt)\nUPPERLETTERS &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;\nLETTERS_AND_SPACE &#x3D; UPPERLETTERS + UPPERLETTERS.lower() + &#39; \\t\\n&#39;\n\ndef loadDictionary():\n    dictionaryFile &#x3D; open(&#39;dictionary.txt&#39;)\n    englishWords &#x3D; &#123;&#125;\n    for word in dictionaryFile.read().split(&#39;\\n&#39;):\n        englishWords[word] &#x3D; None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS &#x3D; loadDictionary()\n\n\ndef getEnglishCount(message):\n    message &#x3D; message.upper()\n    message &#x3D; removeNonLetters(message)\n    possibleWords &#x3D; message.split()\n\n    if possibleWords &#x3D;&#x3D; []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches &#x3D; 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches +&#x3D; 1\n    return float(matches) &#x2F; len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly &#x3D; []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return &#39;&#39;.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage&#x3D;20, letterPercentage&#x3D;85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch &#x3D; getEnglishCount(message) * 100 &gt;&#x3D; wordPercentage\n    numLetters &#x3D; len(removeNonLetters(message))\n    messageLettersPercentage &#x3D; float(numLetters) &#x2F; len(message) * 100\n    lettersMatch &#x3D; messageLettersPercentage &gt;&#x3D; letterPercentage\n    return wordsMatch and lettersMatch</code></pre>\n\n<p>这个脚本能帮我们淘汰掉很多种情况，但还是不能唯一得出密文，为了更好锁定密文，对于长文本来说可以引入词频分析，确定明文中E的正确位置(仿射加密本质是更简单的单表替换，出现频率最多的字符大概率就是E),帮助更好的判断出正确的明文</p>\n<p>最后的脚本如下(对长密文适用)：</p>\n<h3 id=\"AffineHack-py\"><a href=\"#AffineHack-py\" class=\"headerlink\" title=\"AffineHack.py\"></a>AffineHack.py</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#Affine Cipher Hacker\nimport math,sys,detectEnglish,wordninja\nfrom gmpy2 import invert\n\nenglishLetterFrea&#x3D;&#123;&#39;E&#39;:12.7,&#39;T&#39;:9.06,&#39;A&#39;:8.17,&#39;O&#39;:7.51,&#39;I&#39;:6.97,&#39;N&#39;:6.75,&#39;S&#39;:6.33,&#39;H&#39;:6.09,&#39;R&#39;:5.99,&#39;D&#39;:4.25,&#39;L&#39;:4.03,&#39;C&#39;:2.78,&#39;U&#39;:2.76,&#39;M&#39;:2.41,&#39;W&#39;:2.36,&#39;F&#39;:2.23,&#39;G&#39;:2.02,&#39;Y&#39;:1.97,&#39;P&#39;:1.93,&#39;B&#39;:1.29,&#39;V&#39;:0.98,&#39;K&#39;:0.77,&#39;J&#39;:0.15,&#39;X&#39;:0.15,&#39;Q&#39;:0.10,&#39;Z&#39;:0.07&#125;\n\n\nETAOIN&#x3D;&#39;ETAOINSHRDLCUMWFGYPBVKJXQZ&#39;  #英文中词频排列顺序（降序）\n\nSymbols&#x3D;&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;  #明文空间 密文空间\n\ndef getLetterCount(message):\n\n#统计字符串中每个字母的数量\n\tLetterCount&#x3D;&#123;&#39;A&#39;:0,&#39;B&#39;:0,&#39;C&#39;:0,&#39;D&#39;:0,&#39;E&#39;:0,&#39;F&#39;:0,&#39;G&#39;:0,&#39;H&#39;:0,&#39;I&#39;:0,&#39;J&#39;:0,&#39;K&#39;:0,&#39;L&#39;:0,&#39;M&#39;:0,&#39;N&#39;:0,&#39;O&#39;:0,&#39;P&#39;:0,&#39;Q&#39;:0,&#39;R&#39;:0,&#39;S&#39;:0,&#39;T&#39;:0,&#39;U&#39;:0,&#39;V&#39;:0,&#39;W&#39;:0,&#39;X&#39;:0,&#39;Y&#39;:0,&#39;Z&#39;:0&#125;\n\n\tfor i in message.upper():\n\t\tif i in Symbols:\n\t\t\tLetterCount[i]+&#x3D;1\n\t\n\treturn LetterCount\n\n\n\ndef getItemAtIndexZero(x):\n#返回变量的下标为0的值\n\treturn x[0]\n\ndef getFrequencyOrder(message):\n#按照字母出现的次数排序\n\tletterToFreq&#x3D;getLetterCount(message) #字母到次数的映射\n\tfreqToLetter&#x3D;&#123;&#125; #次数到字母的映射\n\n\tfor i in Symbols:          \n\t\tif letterToFreq[i] not in freqToLetter:   #判断字母对应次数是否是字典freqToLetter的键，若不是则以该次数为键，以对于的字母为值；若是，则在最后追加一组键值对\n\t\t\tfreqToLetter[letterToFreq[i]]&#x3D;[i]     #因为次数可能出现相同的情况\n\t\telse:\n\t\t\tfreqToLetter[letterToFreq[i]].append(i)\n\n\tfor freq in freqToLetter:\n\t\tfreqToLetter[freq].sort(key&#x3D;ETAOIN.find,reverse&#x3D;True)  #将同一次数的键所对应的字母按照ETAOIN的降序排列(做一个约定)\n\t\tfreqToLetter[freq]&#x3D;&#39;&#39;.join(freqToLetter[freq])\n\n\tfreqPairs&#x3D;list(freqToLetter.items())                 #将字典变成一个元组列表\n\tfreqPairs.sort(key&#x3D;getItemAtIndexZero,reverse&#x3D;True)  #按照元组列表索引为0的值排序\n\n\treturn freqPairs\n\n\n\n\ndef getKey(key):\n\t#得到两个ab密钥\n\tkey_a&#x3D;key&#x2F;&#x2F;len(Symbols)\n\tkey_b&#x3D;key%len(Symbols)\n\treturn (key_a,key_b)\n\ndef checkKeys(key_a,key_b,mode):\n\t#检查密钥是否合法\n\tif mode&#x3D;&#x3D;&#39;encrypt&#39;:\n\t\tif key_a&#x3D;&#x3D;1 or key_b&#x3D;&#x3D;1:\n\t\t\tsys.exit(&#39;太简单&#39;)\n\tif key_a&lt;0 or key_b&lt;0 or key_b&gt;len(Symbols)-1:\n\t\tsys.exit(&#39;不属于区间(0,len(Symbols))&#39;)\n\tif math.gcd(key_a,len(Symbols))!&#x3D;1:\n\t\tsys.exit(&#39;密钥a和模数不互素&#39;)\n\ndef decryptM(key,message):\n\t#已知密钥的仿射解密\n\tK1,K2&#x3D;getKey(key)\n\tcheckKeys(K1,K2,&#39;decrypt&#39;)\n\tresult&#x3D;&#39;&#39;\n\tmodInverseOfKeya&#x3D;invert(K1,len(Symbols))    #求密钥a的模逆元\n\n\tfor i in message:\n\t\tif i in Symbols:\n\t\t\tIndex&#x3D;Symbols.find(i)\n\t\t\tresult+&#x3D;Symbols[((Index-K2)*modInverseOfKeya)%len(Symbols)]\n\t\telse:\n\t\t\tresult+&#x3D;i\n\n\treturn result\n\ndef hackAffine(message):  \n#爆破得到明文\n\tcnt&#x3D;0 #最后输出的可能解密结果数\n\n\tMax&#x3D;getFrequencyOrder(message)[0][1]\n\n\tfor i in message:\n\t\tif i&#x3D;&#x3D;Max:\n\t\t\tind &#x3D; message.find(i)   #找到E所在的位置\n\t\t\tbreak\n#                  \n\tprint(&#39;hacking start&#39;)\n\n\tfor key in range(len(Symbols)**2):   #爆破密钥\n\t\tkey_a&#x3D;getKey(key)[0]\n\t\tif math.gcd(key_a,len(Symbols))!&#x3D;1:  #密钥a要和模数互素\n\t\t\tcontinue\n\n\t\tresult&#x3D;decryptM(key,message)  #将密钥带入根据公式求出对应明文\n\n\t\tif result[ind]&#x3D;&#x3D;&#39;E&#39;:\n\t\t\t#print(&#39;tried key %s...(%s)&#39;%(key,result[:20]))\n\t\t\ttext&#x3D;&#39; &#39;.join(wordninja.split(result))  #利用wordninja工具给字符串分词，这样才能用detectEnglish判断是否是英文\n\t\t\tif detectEnglish.isEnglish(text):    #利用detectEnglish判断是否是英文\n\t\t\t\tcnt+&#x3D;1\n\t\t\t\tprint(&#39;possible encryption hack:&#39;)\n\t\t\t\tprint(&#39;key:%s&#39;%(key))\n\t\t\t\tprint(&#39;c:&#39;+result[:50])\n\t\t\t\tprint(text)                      #输出最后可能结果\n\treturn cnt\n\ndef main():\n\tMessage&#x3D;&#39;FMXVEDKAPHFERBNDKRXRSREFMORUDSDKDVSHVUFEDKAPRKDLYEVLRHHRH&#39;  # 输入密文\n\n\tHackedM&#x3D;hackAffine(Message)\n\n\tif HackedM!&#x3D;0:           #如果最后测得的可能解不为0，则成功解密\n\t\tprint(&#39;Success&#39;)\n\telse:\n\t\tprint(&#39;Failed&#39;)\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n\tmain()\n</code></pre>\n\n<h2 id=\"3-运行示例\"><a href=\"#3-运行示例\" class=\"headerlink\" title=\"3.运行示例\"></a>3.运行示例</h2><p><img src=\"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202209241141751.png\" alt=\"image-20220924114055620\"></p>\n","feature":true,"text":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度 以26位大写字母为密文空间的加密表达式如下：$$m&#x3D;ac+b(mod26)$$m&#x3D;ac+b(mod 26) 2.破译仿射加密(以26位大写字母为密文空间为例)在已知...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BB%BF%E5%B0%84%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">密码学编程之仿射解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">1.仿射加密</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%A0%B4%E8%AF%91%E4%BB%BF%E5%B0%84%E5%8A%A0%E5%AF%86-%E4%BB%A526%E4%BD%8D%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E4%B8%BA%E5%AF%86%E6%96%87%E7%A9%BA%E9%97%B4%E4%B8%BA%E4%BE%8B\"><span class=\"toc-text\">2.破译仿射加密(以26位大写字母为密文空间为例)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#detectEnglish-py\"><span class=\"toc-text\">detectEnglish.py</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AffineHack-py\"><span class=\"toc-text\">AffineHack.py</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">3.运行示例</span></a></li></ol></li></ol>","author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"密码学编程之维吉尼亚解密","uid":"7578f0af2d88f971b7e36554470841ec","slug":"密码学编程之维吉尼亚解密","date":"2022-10-02T07:03:43.000Z","updated":"2022-10-02T08:58:19.503Z","comments":true,"path":"api/articles/密码学编程之维吉尼亚解密.json","keywords":null,"cover":[],"text":"密码学编程之维吉尼亚解密1.什么是维吉尼亚密码它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"}],"author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"typora+picgo+github图床搭建","uid":"ce37acc016e9206d79635834f119399c","slug":"typora-picgo-github图床搭建","date":"2022-07-28T15:04:49.000Z","updated":"2022-07-28T16:41:22.052Z","comments":true,"path":"api/articles/typora-picgo-github图床搭建.json","keywords":null,"cover":[],"text":"typora+picgo+github 图床搭建及常见问题解决方式1.创建GitHub账号GitHub网址： https://github.com/ 2.创建仓库 3.获取token进入设置 进入developer setting 注意repo一定要选择 获取token，记得复制...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"PicGo","slug":"PicGo","count":1,"path":"api/tags/PicGo.json"}],"author":{"name":"重言","slug":"blog-author","avatar":"https://testingcf.jsdelivr.net/gh/c1ongyan/picture@main/img/202210022256981.jpg","link":"/","description":"一个打算开始捣鼓的小白","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}