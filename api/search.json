[{"id":"d57c63b0ac830d2c732299e1855fc44f","title":"密码学编程之仿射解密","content":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度\n以26位大写字母为密文空间的加密表达式如下：$$m&#x3D;ac+b(mod26)$$m&#x3D;ac+b(mod 26)\n2.破译仿射加密(以26位大写字母为密文空间为例)在已知密钥a和b的情况下可以很容易求出密文\n以26位大写字母为密文空间的解密表达式如下：$$c&#x3D;(m-b)a^{-1}(mod 26)$$在不知道密钥a和密钥b的情况下由于密钥空间小也很好爆破，因为为了保证能还原明文，必须要能够求出a的逆，这就要求a和26要互素，这样a只有12种可能，b有26种可能，总共1226-1种可能，非常少，爆破很快。\n但要找出正确的一种可能用肉眼看太麻烦了，可以写一个判断是否是英文的脚本筛选一下，给出一个Al写的脚本detectEnglish.py：(注意需要有一个英文字典txt文件 dictionary.txt)\ndetectEnglish.py# Detect English module\n# http:&#x2F;&#x2F;inventwithpython.com&#x2F;hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a &quot;dictionary.txt&quot; file in this directory with all English\n# words in it, one word per line. You can download this from\n# http:&#x2F;&#x2F;invpy.com&#x2F;dictionary.txt)\nUPPERLETTERS &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;\nLETTERS_AND_SPACE &#x3D; UPPERLETTERS + UPPERLETTERS.lower() + &#39; \\t\\n&#39;\n\ndef loadDictionary():\n    dictionaryFile &#x3D; open(&#39;dictionary.txt&#39;)\n    englishWords &#x3D; &#123;&#125;\n    for word in dictionaryFile.read().split(&#39;\\n&#39;):\n        englishWords[word] &#x3D; None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS &#x3D; loadDictionary()\n\n\ndef getEnglishCount(message):\n    message &#x3D; message.upper()\n    message &#x3D; removeNonLetters(message)\n    possibleWords &#x3D; message.split()\n\n    if possibleWords &#x3D;&#x3D; []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches &#x3D; 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches +&#x3D; 1\n    return float(matches) &#x2F; len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly &#x3D; []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return &#39;&#39;.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage&#x3D;20, letterPercentage&#x3D;85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch &#x3D; getEnglishCount(message) * 100 &gt;&#x3D; wordPercentage\n    numLetters &#x3D; len(removeNonLetters(message))\n    messageLettersPercentage &#x3D; float(numLetters) &#x2F; len(message) * 100\n    lettersMatch &#x3D; messageLettersPercentage &gt;&#x3D; letterPercentage\n    return wordsMatch and lettersMatch\n\n这个脚本能帮我们淘汰掉很多种情况，但还是不能唯一得出密文，为了更好锁定密文，对于长文本来说可以引入词频分析，确定明文中E的正确位置(仿射加密本质是更简单的单表替换，出现频率最多的字符大概率就是E),帮助更好的判断出正确的明文\n最后的脚本如下(对长密文适用)：\nAffineHack.py#Affine Cipher Hacker\nimport math,sys,detectEnglish,wordninja\nfrom gmpy2 import invert\n\nenglishLetterFrea&#x3D;&#123;&#39;E&#39;:12.7,&#39;T&#39;:9.06,&#39;A&#39;:8.17,&#39;O&#39;:7.51,&#39;I&#39;:6.97,&#39;N&#39;:6.75,&#39;S&#39;:6.33,&#39;H&#39;:6.09,&#39;R&#39;:5.99,&#39;D&#39;:4.25,&#39;L&#39;:4.03,&#39;C&#39;:2.78,&#39;U&#39;:2.76,&#39;M&#39;:2.41,&#39;W&#39;:2.36,&#39;F&#39;:2.23,&#39;G&#39;:2.02,&#39;Y&#39;:1.97,&#39;P&#39;:1.93,&#39;B&#39;:1.29,&#39;V&#39;:0.98,&#39;K&#39;:0.77,&#39;J&#39;:0.15,&#39;X&#39;:0.15,&#39;Q&#39;:0.10,&#39;Z&#39;:0.07&#125;\n\n\nETAOIN&#x3D;&#39;ETAOINSHRDLCUMWFGYPBVKJXQZ&#39;  #英文中词频排列顺序（降序）\n\nSymbols&#x3D;&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;  #明文空间 密文空间\n\ndef getLetterCount(message):\n\n#统计字符串中每个字母的数量\n\tLetterCount&#x3D;&#123;&#39;A&#39;:0,&#39;B&#39;:0,&#39;C&#39;:0,&#39;D&#39;:0,&#39;E&#39;:0,&#39;F&#39;:0,&#39;G&#39;:0,&#39;H&#39;:0,&#39;I&#39;:0,&#39;J&#39;:0,&#39;K&#39;:0,&#39;L&#39;:0,&#39;M&#39;:0,&#39;N&#39;:0,&#39;O&#39;:0,&#39;P&#39;:0,&#39;Q&#39;:0,&#39;R&#39;:0,&#39;S&#39;:0,&#39;T&#39;:0,&#39;U&#39;:0,&#39;V&#39;:0,&#39;W&#39;:0,&#39;X&#39;:0,&#39;Y&#39;:0,&#39;Z&#39;:0&#125;\n\n\tfor i in message.upper():\n\t\tif i in Symbols:\n\t\t\tLetterCount[i]+&#x3D;1\n\t\n\treturn LetterCount\n\n\n\ndef getItemAtIndexZero(x):\n#返回变量的下标为0的值\n\treturn x[0]\n\ndef getFrequencyOrder(message):\n#按照字母出现的次数排序\n\tletterToFreq&#x3D;getLetterCount(message) #字母到次数的映射\n\tfreqToLetter&#x3D;&#123;&#125; #次数到字母的映射\n\n\tfor i in Symbols:          \n\t\tif letterToFreq[i] not in freqToLetter:   #判断字母对应次数是否是字典freqToLetter的键，若不是则以该次数为键，以对于的字母为值；若是，则在最后追加一组键值对\n\t\t\tfreqToLetter[letterToFreq[i]]&#x3D;[i]     #因为次数可能出现相同的情况\n\t\telse:\n\t\t\tfreqToLetter[letterToFreq[i]].append(i)\n\n\tfor freq in freqToLetter:\n\t\tfreqToLetter[freq].sort(key&#x3D;ETAOIN.find,reverse&#x3D;True)  #将同一次数的键所对应的字母按照ETAOIN的降序排列(做一个约定)\n\t\tfreqToLetter[freq]&#x3D;&#39;&#39;.join(freqToLetter[freq])\n\n\tfreqPairs&#x3D;list(freqToLetter.items())                 #将字典变成一个元组列表\n\tfreqPairs.sort(key&#x3D;getItemAtIndexZero,reverse&#x3D;True)  #按照元组列表索引为0的值排序\n\n\treturn freqPairs\n\n\n\n\ndef getKey(key):\n\t#得到两个ab密钥\n\tkey_a&#x3D;key&#x2F;&#x2F;len(Symbols)\n\tkey_b&#x3D;key%len(Symbols)\n\treturn (key_a,key_b)\n\ndef checkKeys(key_a,key_b,mode):\n\t#检查密钥是否合法\n\tif mode&#x3D;&#x3D;&#39;encrypt&#39;:\n\t\tif key_a&#x3D;&#x3D;1 or key_b&#x3D;&#x3D;1:\n\t\t\tsys.exit(&#39;太简单&#39;)\n\tif key_a&lt;0 or key_b&lt;0 or key_b&gt;len(Symbols)-1:\n\t\tsys.exit(&#39;不属于区间(0,len(Symbols))&#39;)\n\tif math.gcd(key_a,len(Symbols))!&#x3D;1:\n\t\tsys.exit(&#39;密钥a和模数不互素&#39;)\n\ndef decryptM(key,message):\n\t#已知密钥的仿射解密\n\tK1,K2&#x3D;getKey(key)\n\tcheckKeys(K1,K2,&#39;decrypt&#39;)\n\tresult&#x3D;&#39;&#39;\n\tmodInverseOfKeya&#x3D;invert(K1,len(Symbols))    #求密钥a的模逆元\n\n\tfor i in message:\n\t\tif i in Symbols:\n\t\t\tIndex&#x3D;Symbols.find(i)\n\t\t\tresult+&#x3D;Symbols[((Index-K2)*modInverseOfKeya)%len(Symbols)]\n\t\telse:\n\t\t\tresult+&#x3D;i\n\n\treturn result\n\ndef hackAffine(message):  \n#爆破得到明文\n\tcnt&#x3D;0 #最后输出的可能解密结果数\n\n\tMax&#x3D;getFrequencyOrder(message)[0][1]\n\n\tfor i in message:\n\t\tif i&#x3D;&#x3D;Max:\n\t\t\tind &#x3D; message.find(i)   #找到E所在的位置\n\t\t\tbreak\n#                  \n\tprint(&#39;hacking start&#39;)\n\n\tfor key in range(len(Symbols)**2):   #爆破密钥\n\t\tkey_a&#x3D;getKey(key)[0]\n\t\tif math.gcd(key_a,len(Symbols))!&#x3D;1:  #密钥a要和模数互素\n\t\t\tcontinue\n\n\t\tresult&#x3D;decryptM(key,message)  #将密钥带入根据公式求出对应明文\n\n\t\tif result[ind]&#x3D;&#x3D;&#39;E&#39;:\n\t\t\t#print(&#39;tried key %s...(%s)&#39;%(key,result[:20]))\n\t\t\ttext&#x3D;&#39; &#39;.join(wordninja.split(result))  #利用wordninja工具给字符串分词，这样才能用detectEnglish判断是否是英文\n\t\t\tif detectEnglish.isEnglish(text):    #利用detectEnglish判断是否是英文\n\t\t\t\tcnt+&#x3D;1\n\t\t\t\tprint(&#39;possible encryption hack:&#39;)\n\t\t\t\tprint(&#39;key:%s&#39;%(key))\n\t\t\t\tprint(&#39;c:&#39;+result[:50])\n\t\t\t\tprint(text)                      #输出最后可能结果\n\treturn cnt\n\ndef main():\n\tMessage&#x3D;&#39;FMXVEDKAPHFERBNDKRXRSREFMORUDSDKDVSHVUFEDKAPRKDLYEVLRHHRH&#39;  # 输入密文\n\n\tHackedM&#x3D;hackAffine(Message)\n\n\tif HackedM!&#x3D;0:           #如果最后测得的可能解不为0，则成功解密\n\t\tprint(&#39;Success&#39;)\n\telse:\n\t\tprint(&#39;Failed&#39;)\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n\tmain()\n\n\n3.运行示例\n","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","categories_index":"","tags_index":"","author_index":"重言"},{"id":"ce37acc016e9206d79635834f119399c","title":"typora+picgo+github图床搭建","content":"typora+picgo+github 图床搭建及常见问题解决方式1.创建GitHub账号GitHub网址：\nhttps://github.com/\n2.创建仓库\n\n3.获取token进入设置\n\n\n进入developer setting\n\n\n注意repo一定要选择\n获取token，记得复制，只显示一次\n4.下载安装picgo下载地址：https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0\nWindows选择如下图的文件\n\n下载后安装\n5.配置github图床（注意安装好后点击桌面Picgo图标没有应用界面，需要再点击右下角的工具栏里的相应图标）\n按照如图所示进行配置\n\n在picgo设置中开启时间戳重命名，防止出现上传同名文件的422报错\n\n6.配置typora打开typora –》选择文件–》选择偏好设置–》选择图像\n按照下列设置，最后验证图片上传选项\n\n最后显示如下图则成功\n\n7.常见问题1.最后验证图片无法上传成功：upload error查看日志：404 可能是配置picgo的时候用户名，仓库名等其他配置写错，仔细检查一遍\n查看日志：422 是上传同名文件的报错，在picgo设置中开启时间戳重命名设置可避免\n2.验证成功上传但是在typora无法查看图片2.1修改hosts文件：利用记事本打开：C:\\Windows\\System32\\drivers\\etc\\hosts （以管理员身份打开记事本，在记事本中打开文件，记得选择全部文件，不然没有显示）\n添加如下的内容到hosts中\n# GitHub Start \n140.82.113.3      github.com\n140.82.114.20     gist.github.com\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n199.232.68.133     avatars0.githubusercontent.com\n199.232.28.133     avatars1.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n199.232.28.133     avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n199.232.68.133     avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n199.232.68.133     avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n199.232.68.133     avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n199.232.68.133     avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n199.232.68.133     avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n199.232.68.133     avatars8.githubusercontent.com\n185.199.111.133    raw.githubusercontent.com \n185.199.110.133    raw.githubusercontent.com \n185.199.108.133    raw.githubusercontent.com \n185.199.109.133    raw.githubusercontent.com \n# GitHub End\n\n\n\n2.2检查配置是否写错我在遇到这些问题的时候很多时候都是配置写错了的问题\n2.3重启最后解决不了就重启一遍软件，还是在picgo相册中不显示（前面的不会显示，每次都再重新验证一遍），就重装picgo(我只重启过，看别的博主说可以通过重装解决)\n","slug":"typora-picgo-github图床搭建","date":"2022-07-28T15:04:49.000Z","categories_index":"","tags_index":"PicGo","author_index":"重言"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"","slug":"我的第一篇文章","date":"2022-07-27T17:43:26.000Z","categories_index":"","tags_index":"","author_index":"重言"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-07-27T17:32:29.616Z","categories_index":"","tags_index":"","author_index":"重言"}]