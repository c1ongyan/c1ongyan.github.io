[{"id":"7578f0af2d88f971b7e36554470841ec","title":"密码学编程之维吉尼亚解密","content":"密码学编程之维吉尼亚解密1.什么是维吉尼亚密码它是典型的多表代换密码，它的加密过程可以通过查表来表示，密文字母为横列，密钥字母为纵列（可以互换），对应得到的字母为加密后的密文，相当于每个字母都选择了一个偏移值来进行凯撒加密，但为了增强密码的可用性与简洁性，维吉尼亚的密钥采取周期式的密钥，即每隔一个周期用同一张表（即同一偏移）来加密。\n\n示例：\n密钥为：encryption\n明文为：publickeydistribution\n\n2.维吉尼亚解密2.1已知密钥的维吉尼亚解密思路：做加密的逆过程即可。加密是按照密钥进行凯撒加密，解密就是按照密钥进行凯撒解密。\nimport wordninja #wordninja是分词工具\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result)) #对解密结果按英文分词，增加可读性\n\n\treturn text\n\n\ndef main():\n\tmessage='krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy'\n\tkey='CRYPTO'\n\tprint(decrypt(key,message.upper()))\n\nif __name__ == '__main__':\n\tmain()\n2.2唯密文的维吉尼亚解密1利用重合指数+重合互指数解密此种方法对于唯密文的维吉尼亚解密是基于语言的统计规律，所以当密文很短是是无法用该方法解密的，对长密文比较适用\n思路：\n1.根据kasiski或者重合指数计算出密钥长度\nKasiski测验法基本原理：用给定长度为k的密钥周期性地对明文加密，则但明文中有两个相同的字母，且对应被加密后的字母也相同时，这两个字母的间距是k的倍数。找到密文中相同字母间隔的最大公因数，很有可能是密钥长度。\n重合指数法：对单表替换而已，并不会改变字符串的统计特性（比如，某个英语字母出现的频率），故其重合指数应该约等于0.065。可以爆破密钥长度，根据密钥长度将同一密钥字母加密的字母放在一个分组内，每个分组都相当于被单表替换，都应满足重合指数应该约等于0.065。\n重合指数:两个随机字母相同的概率（即在一字符串中随机取出两个字母为a的概率+同为b的概率+…）\n​                                                            \n（pi为字母i出现频率）\n重合指数无偏估计值(更准确，用此来计算):\n​                                                            \n（fi为字母i出现次数，n为字符串字符总数）\n代码：\ndef getCnt(string):\n#统计字符出现的次数\n\tLettersZd={'A':0, 'B':0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+=1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi=0\n\tn=0 #总数n\n\tfor k in Zd:\n\t\tfi=fi+Zd[k]*(Zd[k]-1)\n\t\tn=n+Zd[k]\n\n\tp=fi/(n*(n-1))\n\n\treturn p\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt=0\n\tpi=0\n\tfor i in range(1,len(Letters)):\n\t\t#print('key_length=%s'%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr=message[j::i]\n\t\t\tLettersZd=getCnt(str)\n\n\t\t\tpi=getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+=1\n\t\tif cnt==i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt=0\n\t\tpi=0\n2.根据重合互指数得到密钥重合互指数：\n\n当两个子串的相对位移为0时其值为0.065，不为0则都在0.3~0.4左右，故我们可以把其中一子串设为标准英语，另一子串为根据密钥长度分组后的子串，爆破26种偏移，重合互指数最大的应该是子串相对标准英语的偏移，从而确定对应密钥字母。\n\n代码：\ndef getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2=getCnt(str_1)\n\n\tmatrix_1=np.array(Zd_1)\n\tmatrix_2=np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2=np.sum(matrix_2)\n\tpi=matrix_2/n2\n\n\tHp=np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult=''\n\tfor s in string:\n\t\tindex=Letters.find(s)\n\t\tresult=result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm=0\n\tresult=[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring=KaiSa(i,group[num])\n\t\tx=getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm=x\n\t\t\tkey=i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len=getLenKey(message)\n\n\n\tgroup=[] #按照密钥长度分组\n\th_key={} #存储偏移K\n\tMI={} #储存偏移值\n\tLetter_key=''#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]=getListMI(i,group)\n\n\t\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm=Letters[26-h_key[i]]\n\t\tLetter_key=Letter_key+m\n\n\treturn Letter_key\n3.已知密钥的维吉尼亚解密代码：\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result))  #利用wordninja分词工具自动分词，增加明文可读性\n\n\treturn text\n4.完整代码及运行结果示例#维吉尼亚解密：不知道密钥情况下分析密钥，求出密文(适合长密文)\n#思路：1.求出密钥长度：方法可以用kasiski或者重合指数,这里用重合指数法\n#重合指数法思路：爆破key长度，将一组的子串计算重合指数p^2和(近似)，每一个子串重合指数都在0.065左右的则为真实密钥长度\n#2.破解密钥：根据重合互指数，爆破相对偏移\n#3.求解密文:已知密钥求密文\n\n'''\n表达难点：\n子串计算的处理==&gt;直接利用字符串自带的按步长分片\n重合指数的存储判断==&gt;方法一:计算平均值判断\n重合互指数需要将已满足条件的\n如何判断是约等于0.065\n'''\nimport numpy as np\nimport wordninja\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef getCnt(string):\n#统计字符出现的频率\n\tLettersZd={'A':0, 'B':0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}\n\tfor i in string:\n\t\tif i  in LettersZd:\n\t\t\tLettersZd[i]+=1\n\n\treturn LettersZd\n\ndef getIC(Zd):\n#计算重合指数\n\tfi=0\n\tn=0 #总数n\n\tfor k in Zd:\n\t\tfi=fi+Zd[k]*(Zd[k]-1)\n\t\tn=n+Zd[k]\n\n\tp=fi/(n*(n-1))\n\n\treturn p\n\n\ndef getLenKey(message):\n#得到密钥长度\n#方法：计算子串重合指数\n\tcnt=0\n\tpi=0\n\tfor i in range(1,len(Letters)):\n\t\t#print('key_length=%s'%i)\n\t\tfor j in range(1,i+1):\n\t\t\tstr=message[j::i]\n\t\t\tLettersZd=getCnt(str)\n\n\t\t\tpi=getIC(LettersZd)\n\t\t\t\n\t\t\tif pi&gt;0.055 and pi&lt;0.075:\n\t\t\t\tcnt+=1\n\t\tif cnt==i:\n\t\t\treturn i \n\t\t\tbreak\n\t\tcnt=0\n\t\tpi=0\n\n\ndef getMI(str_1):\n#计算子串与标准英语之间的重合互指数\n\tZd_1=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] #英语中a,b,c...z的频率\n\tZd_2=getCnt(str_1)\n\n\tmatrix_1=np.array(Zd_1)\n\tmatrix_2=np.array(list(Zd_2.values()))  #转成数组便于计算内积\n\n\n\tn2=np.sum(matrix_2)\n\tpi=matrix_2/n2\n\n\tHp=np.sum(pi*matrix_1)\n\n\treturn Hp\n\n\n\ndef KaiSa(key,string):\n#按需偏移字符串（凯撒加密）\n\tresult=''\n\tfor s in string:\n\t\tindex=Letters.find(s)\n\t\tresult=result+Letters[(index+key)%len(Letters)]\n\n\treturn result\n\ndef getListMI(num,group):\n#求出num号的子串的26种偏移下的重合互指数，并返回改组中最大互指数对应的偏移\n\tmm=0\n\tresult=[] #存放一组重合互指数\n\tfor i in range(0,len(Letters)):\n\t\tstring=KaiSa(i,group[num])\n\t\tx=getMI(string)\n\t\t#print(x)\n\t\tif x&gt;mm:\n\t\t\tmm=x\n\t\t\tkey=i\n\t\tresult.append(x)\n\n\treturn result,key\n\n\n\n\ndef getKey(message):\n#破解密钥\n\n\tkey_len=getLenKey(message)\n\n\n\tgroup=[] #按照密钥长度分组\n\th_key={} #存储偏移K\n\tMI={} #储存偏移值\n\tLetter_key=''#储存字母加密密钥\n\n\tfor i in range(key_len):    #按照密钥长度分组\n\t\tgroup.append(message[i::key_len])\n\t#print(group)\n\n\t\n\tfor i in range(0,key_len):  #求出每组的所有重合互指数和最大重合互指数对应的偏移\n\t\tMI[i],h_key[i]=getListMI(i,group)\n\n\tfor i in range(key_len):     #根据偏移写出密钥，因为偏移是相对密文的，而密钥则是相对明文的，故要用26-相对密文的偏移\n\t\tm=Letters[(26-h_key[i])%26]\n\t\tLetter_key=Letter_key+m\n\n\treturn Letter_key\n\t\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\tj=(j+1)%l\n\t\tresult=result+Letters[index]\n\n\ttext=' '.join(wordninja.split(result))\n\n\treturn text\n\ndef main():\n\tmessage='krkpewxvftksopztecxvbuhfvycgxouflihoffptrcwffwhkcevxhiuzfposdvccyctpmjtbfymllctiwxtacsmjmoncwdnawjrwtjgjsuystvbxgvcmgczbqecllttfkjlacpfttjgeegtbvkfpmhjzqaxhvvpgxoeychrcwumchhyigixhqdciawunmjerefkekcozqttznfdjlopuyqhjgrjawcpfrgxhwiljgrgiycrqkiajfgvrlrxgkkghdbqnliaovzrltgafslacjvjexrwjrdzsvruprttfkwxfgrlstznnmjerdvjdlhkwwdngjfsawgjfunhitjcaykgrptzicibtwrcpycwbkxfibrqemivotvwdnotvldmvgicshbqkztmfqlzaxrqekntqefscmbqkfxguyzjaaorgccmcovrwxbckgdgonrqhxadcclbznjfdpzgegtgqawygxkgcjiasofqiecxvbdyageztjikvrxymqlapghcbcrtfgfdnhitjcaytqiknlsnwgrtbpfrlkwvvycraqicqnhpfrwbbizliasyfpawqqljslhqgktmccumgxmqlsemcvycsxovy'\n\tmessage=message.replace(\" \", \"\") #清除输入中的空格\n\t#print(message)\n\t#print(getLenKey(message))\n\ts=getKey(message.upper())\n\tprint('密钥为：%s'%s)\n\tt=decrypt(s,message.upper())\n\tprint('解密结果为：%s'%t)\n\n\n\nif __name__ == '__main__':\n\tmain()\n\n\n运行结果：\n\n2.2.2字典攻击代码：import detectEnglish,wordninja\n\nLetters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef decrypt(key,message):\n\n\tresult=''\n\tl=len(key)\n\tj=0\n\n\tfor i in message:\n\t\tif i in Letters:\n\t\t\tindex=(Letters.find(i)-Letters.find(key[j]))%26\n\t\t\tj=(j+1)%l\n\t\t\tresult=result+Letters[index]\n\t\telse:\n\t\t\tresult=result+i\n\n\ttext=' '.join(wordninja.split(result))\n\n\treturn text\n\n\ndef Hack(message):\n\n\tfo=open('dictionary.txt','r')\n\twords=fo.readlines()    #返回一个字符串列表，每个字符串是文件的一行\n\tfo.close()\n\n\t#开始爆破\n\tfor word in words:\n\t\tword=word.strip()\n\t\tst=decrypt(word,message)\n\n\t\t#message=message.replace(\" \", \"\") #清除输入中的空格\n\t\t#print(st)\n\t\tif detectEnglish.isEnglish(st,wordPercentage=40):\n\t\t\tprint(\"密钥可能为%s\"%word)\n\t\t\tprint(\"对应明文可能为%s\"%st)\n\n\ndef main():\n\tmessage='TzxisnzeccjxkgnfqlolmysbbqqIlxcz.'\n\tHack(message.upper())\n\nif __name__ == '__main__':\n\tmain()\ndetectEnglish.py# Detect English module\n# http://inventwithpython.com/hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http://invpy.com/dictionary.txt)\nUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \\t\\n'\n\ndef loadDictionary():\n    dictionaryFile = open('dictionary.txt')\n    englishWords = {}\n    for word in dictionaryFile.read().split('\\n'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) / len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return ''.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) / len(message) * 100\n    lettersMatch = messageLettersPercentage &gt;= letterPercentage\n    return wordsMatch and lettersMatch\n运行结果示例：\n","slug":"密码学编程之维吉尼亚解密","date":"2022-10-02T07:03:43.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"d57c63b0ac830d2c732299e1855fc44f","title":"密码学编程之仿射解密","content":"密码学编程之仿射解密1.仿射加密简单来说就是把密文对应的的数字乘上密钥a再加上b模明文空间长度\n以26位大写字母为密文空间的加密表达式如下：\n\n2.破译仿射加密(以26位大写字母为密文空间为例)在已知密钥a和b的情况下可以很容易求出密文\n以26位大写字母为密文空间的解密表达式如下：\n\n在不知道密钥a和密钥b的情况下由于密钥空间小也很好爆破，因为为了保证能还原明文，必须要能够求出a的逆，这就要求a和26要互素，这样a只有12种可能，b有26种可能，总共12*26-1种可能，非常少，爆破很快。\n但要找出正确的一种可能用肉眼看太麻烦了，可以写一个判断是否是英文的脚本筛选一下，给出一个Al写的脚本detectEnglish.py：(注意需要有一个英文字典txt文件 dictionary.txt)\ndetectEnglish.py# Detect English module\n# http://inventwithpython.com/hacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http://invpy.com/dictionary.txt)\nUPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \\t\\n'\n\ndef loadDictionary():\n    dictionaryFile = open('dictionary.txt')\n    englishWords = {}\n    for word in dictionaryFile.read().split('\\n'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) / len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return ''.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 &gt;= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) / len(message) * 100\n    lettersMatch = messageLettersPercentage &gt;= letterPercentage\n    return wordsMatch and lettersMatch\n这个脚本能帮我们淘汰掉很多种情况，但还是不能唯一得出密文，为了更好锁定密文，对于长文本来说可以引入词频分析，确定明文中E的正确位置(仿射加密本质是更简单的单表替换，出现频率最多的字符大概率就是E),帮助更好的判断出正确的明文\n最后的脚本如下(对长密文适用)：\nAffineHack.py#Affine Cipher Hacker\nimport math,sys,detectEnglish,wordninja\nfrom gmpy2 import invert\n\nenglishLetterFrea={'E':12.7,'T':9.06,'A':8.17,'O':7.51,'I':6.97,'N':6.75,'S':6.33,'H':6.09,'R':5.99,'D':4.25,'L':4.03,'C':2.78,'U':2.76,'M':2.41,'W':2.36,'F':2.23,'G':2.02,'Y':1.97,'P':1.93,'B':1.29,'V':0.98,'K':0.77,'J':0.15,'X':0.15,'Q':0.10,'Z':0.07}\n\n\nETAOIN='ETAOINSHRDLCUMWFGYPBVKJXQZ'  #英文中词频排列顺序（降序）\n\nSymbols='ABCDEFGHIJKLMNOPQRSTUVWXYZ'  #明文空间 密文空间\n\ndef getLetterCount(message):\n\n#统计字符串中每个字母的数量\n\tLetterCount={'A':0,'B':0,'C':0,'D':0,'E':0,'F':0,'G':0,'H':0,'I':0,'J':0,'K':0,'L':0,'M':0,'N':0,'O':0,'P':0,'Q':0,'R':0,'S':0,'T':0,'U':0,'V':0,'W':0,'X':0,'Y':0,'Z':0}\n\n\tfor i in message.upper():\n\t\tif i in Symbols:\n\t\t\tLetterCount[i]+=1\n\t\n\treturn LetterCount\n\n\n\ndef getItemAtIndexZero(x):\n#返回变量的下标为0的值\n\treturn x[0]\n\ndef getFrequencyOrder(message):\n#按照字母出现的次数排序\n\tletterToFreq=getLetterCount(message) #字母到次数的映射\n\tfreqToLetter={} #次数到字母的映射\n\n\tfor i in Symbols:          \n\t\tif letterToFreq[i] not in freqToLetter:   #判断字母对应次数是否是字典freqToLetter的键，若不是则以该次数为键，以对于的字母为值；若是，则在最后追加一组键值对\n\t\t\tfreqToLetter[letterToFreq[i]]=[i]     #因为次数可能出现相同的情况\n\t\telse:\n\t\t\tfreqToLetter[letterToFreq[i]].append(i)\n\n\tfor freq in freqToLetter:\n\t\tfreqToLetter[freq].sort(key=ETAOIN.find,reverse=True)  #将同一次数的键所对应的字母按照ETAOIN的降序排列(做一个约定)\n\t\tfreqToLetter[freq]=''.join(freqToLetter[freq])\n\n\tfreqPairs=list(freqToLetter.items())                 #将字典变成一个元组列表\n\tfreqPairs.sort(key=getItemAtIndexZero,reverse=True)  #按照元组列表索引为0的值排序\n\n\treturn freqPairs\n\n\n\n\ndef getKey(key):\n\t#得到两个ab密钥\n\tkey_a=key//len(Symbols)\n\tkey_b=key%len(Symbols)\n\treturn (key_a,key_b)\n\ndef checkKeys(key_a,key_b,mode):\n\t#检查密钥是否合法\n\tif mode=='encrypt':\n\t\tif key_a==1 or key_b==1:\n\t\t\tsys.exit('太简单')\n\tif key_a&lt;0 or key_b&lt;0 or key_b&gt;len(Symbols)-1:\n\t\tsys.exit('不属于区间(0,len(Symbols))')\n\tif math.gcd(key_a,len(Symbols))!=1:\n\t\tsys.exit('密钥a和模数不互素')\n\ndef decryptM(key,message):\n\t#已知密钥的仿射解密\n\tK1,K2=getKey(key)\n\tcheckKeys(K1,K2,'decrypt')\n\tresult=''\n\tmodInverseOfKeya=invert(K1,len(Symbols))    #求密钥a的模逆元\n\n\tfor i in message:\n\t\tif i in Symbols:\n\t\t\tIndex=Symbols.find(i)\n\t\t\tresult+=Symbols[((Index-K2)*modInverseOfKeya)%len(Symbols)]\n\t\telse:\n\t\t\tresult+=i\n\n\treturn result\n\ndef hackAffine(message):  \n#爆破得到明文\n\tcnt=0 #最后输出的可能解密结果数\n\n\tMax=getFrequencyOrder(message)[0][1]\n\n\tfor i in message:\n\t\tif i==Max:\n\t\t\tind = message.find(i)   #找到E所在的位置\n\t\t\tbreak\n#                  \n\tprint('hacking start')\n\n\tfor key in range(len(Symbols)**2):   #爆破密钥\n\t\tkey_a=getKey(key)[0]\n\t\tif math.gcd(key_a,len(Symbols))!=1:  #密钥a要和模数互素\n\t\t\tcontinue\n\n\t\tresult=decryptM(key,message)  #将密钥带入根据公式求出对应明文\n\n\t\tif result[ind]=='E':\n\t\t\t#print('tried key %s...(%s)'%(key,result[:20]))\n\t\t\ttext=' '.join(wordninja.split(result))  #利用wordninja工具给字符串分词，这样才能用detectEnglish判断是否是英文\n\t\t\tif detectEnglish.isEnglish(text):    #利用detectEnglish判断是否是英文\n\t\t\t\tcnt+=1\n\t\t\t\tprint('possible encryption hack:')\n\t\t\t\tprint('key:%s'%(key))\n\t\t\t\tprint('c:'+result[:50])\n\t\t\t\tprint(text)                      #输出最后可能结果\n\treturn cnt\n\ndef main():\n\tMessage='FMXVEDKAPHFERBNDKRXRSREFMORUDSDKDVSHVUFEDKAPRKDLYEVLRHHRH'  # 输入密文\n\n\tHackedM=hackAffine(Message)\n\n\tif HackedM!=0:           #如果最后测得的可能解不为0，则成功解密\n\t\tprint('Success')\n\telse:\n\t\tprint('Failed')\n\nif __name__=='__main__':\n\tmain()\n\n3.运行示例\n","slug":"密码学编程之仿射解密","date":"2022-09-24T02:54:54.000Z","categories_index":"","tags_index":"密码学","author_index":"c1ongyan"},{"id":"ce37acc016e9206d79635834f119399c","title":"typora+picgo+github图床搭建","content":"typora+picgo+github 图床搭建及常见问题解决方式1.创建GitHub账号GitHub网址：\nhttps://github.com/\n2.创建仓库\n\n3.获取token进入设置\n\n\n进入developer setting\n\n\n注意repo一定要选择\n获取token，记得复制，只显示一次\n4.下载安装picgo下载地址：https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0\nWindows选择如下图的文件\n\n下载后安装\n5.配置github图床（注意安装好后点击桌面Picgo图标没有应用界面，需要再点击右下角的工具栏里的相应图标）\n按照如图所示进行配置\n\n在picgo设置中开启时间戳重命名，防止出现上传同名文件的422报错\n\n6.配置typora打开typora —》选择文件—》选择偏好设置—》选择图像\n按照下列设置，最后验证图片上传选项\n\n最后显示如下图则成功\n\n7.常见问题1.最后验证图片无法上传成功：upload error查看日志：404 可能是配置picgo的时候用户名，仓库名等其他配置写错，仔细检查一遍\n查看日志：422 是上传同名文件的报错，在picgo设置中开启时间戳重命名设置可避免\n2.验证成功上传但是在typora无法查看图片2.1修改hosts文件：利用记事本打开：C:\\Windows\\System32\\drivers\\etc\\hosts （以管理员身份打开记事本，在记事本中打开文件，记得选择全部文件，不然没有显示）\n添加如下的内容到hosts中\n# GitHub Start \n140.82.113.3      github.com\n140.82.114.20     gist.github.com\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n199.232.68.133     avatars0.githubusercontent.com\n199.232.28.133     avatars1.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n199.232.28.133     avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n199.232.68.133     avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n199.232.68.133     avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n199.232.68.133     avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n199.232.68.133     avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n199.232.68.133     avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n199.232.68.133     avatars8.githubusercontent.com\n185.199.111.133    raw.githubusercontent.com \n185.199.110.133    raw.githubusercontent.com \n185.199.108.133    raw.githubusercontent.com \n185.199.109.133    raw.githubusercontent.com \n# GitHub End\n2.2检查配置是否写错我在遇到这些问题的时候很多时候都是配置写错了的问题\n2.3重启最后解决不了就重启一遍软件，还是在picgo相册中不显示（前面的不会显示，每次都再重新验证一遍），就重装picgo(我只重启过，看别的博主说可以通过重装解决)\n","slug":"typora-picgo-github图床搭建","date":"2022-07-28T15:04:49.000Z","categories_index":"","tags_index":"PicGo","author_index":"c1ongyan"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"","slug":"我的第一篇文章","date":"2022-07-27T17:43:26.000Z","categories_index":"","tags_index":"","author_index":"c1ongyan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2022-07-27T17:32:29.616Z","categories_index":"","tags_index":"","author_index":"c1ongyan"}]